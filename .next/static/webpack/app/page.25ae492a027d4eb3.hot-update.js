"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/firebase.ts":
/*!*************************!*\
  !*** ./lib/firebase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   app: () => (/* binding */ app),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   getActiveRoute: () => (/* binding */ getActiveRoute),\n/* harmony export */   getAllLocationsFromCollection: () => (/* binding */ getAllLocationsFromCollection),\n/* harmony export */   getCurrentScheduleStatus: () => (/* binding */ getCurrentScheduleStatus),\n/* harmony export */   getDateCollections: () => (/* binding */ getDateCollections),\n/* harmony export */   getMonthSchedule: () => (/* binding */ getMonthSchedule),\n/* harmony export */   getRealtimeLocations: () => (/* binding */ getRealtimeLocations),\n/* harmony export */   getSavedRoute: () => (/* binding */ getSavedRoute),\n/* harmony export */   getSavedRoutes: () => (/* binding */ getSavedRoutes),\n/* harmony export */   saveCustomRoute: () => (/* binding */ saveCustomRoute),\n/* harmony export */   saveMonthSchedule: () => (/* binding */ saveMonthSchedule),\n/* harmony export */   saveRouteAsActive: () => (/* binding */ saveRouteAsActive)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _utils_simplify_route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/simplify-route */ \"(app-pages-browser)/./lib/utils/simplify-route.ts\");\n\n\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyDT5K8KNKYv1FpJYuL9bZcd8JSrfu1ekpw\",\n    authDomain: \"grsl-tracker.firebaseapp.com\",\n    projectId: \"grsl-tracker\",\n    storageBucket: \"grsl-tracker.firebasestorage.app\",\n    messagingSenderId: \"64998644297\",\n    appId: \"1:64998644297:web:81a4bc49689fa6877d3d98\",\n    measurementId: \"G-SZVGQRVQ8C\"\n};\n// Initialize Firebase (singleton pattern)\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length === 0 ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig) : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)()[0];\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n\nfunction getRealtimeLocations(collectionName, callback) {\n    const locationsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, collectionName);\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(locationsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"timestamp\", \"asc\"));\n    const unsubscribe = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(q, (snapshot)=>{\n        const locations = [];\n        snapshot.forEach((doc)=>{\n            const data = doc.data();\n            locations.push({\n                id: doc.id,\n                latitude: data.latitude,\n                longitude: data.longitude,\n                timestamp: data.timestamp instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp ? data.timestamp.toDate() : new Date(data.timestamp),\n                speed: data.speed,\n                accuracy: data.accuracy\n            });\n        });\n        callback(locations);\n    }, (error)=>{\n        console.error(\"[v0] Firestore error:\", error);\n    });\n    return unsubscribe;\n}\nasync function getActiveRoute() {\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"settings\", \"active-route\");\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            const data = docSnap.data();\n            return data.routeId;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[v0] Error getting active route:\", error);\n        return null;\n    }\n}\nasync function getSavedRoute(routeId) {\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"saved-routes\", routeId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            return docSnap.data();\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[v0] Error getting saved route:\", error);\n        return null;\n    }\n}\nasync function getSavedRoutes() {\n    try {\n        const routesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"saved-routes\");\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(routesRef);\n        return snapshot.docs.map((docSnap)=>{\n            var _data_points;\n            const data = docSnap.data();\n            return {\n                id: docSnap.id,\n                name: data.name || docSnap.id,\n                pointCount: ((_data_points = data.points) === null || _data_points === void 0 ? void 0 : _data_points.length) || 0\n            };\n        });\n    } catch (error) {\n        console.error(\"[v0] Error listing saved routes:\", error);\n        return [];\n    }\n}\nasync function getDateCollections() {\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"date-index\", \"dates\");\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            const data = docSnap.data();\n            const dateList = data.dateList;\n            // Sort by date descending (newest first)\n            return dateList.sort((a, b)=>{\n                const dateA = a.split(\"_\")[0];\n                const dateB = b.split(\"_\")[0];\n                return dateB.localeCompare(dateA);\n            });\n        }\n        return [];\n    } catch (error) {\n        console.error(\"[v0] Error getting date index:\", error);\n        return [];\n    }\n}\nasync function getAllLocationsFromCollection(collectionName) {\n    try {\n        const locationsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, collectionName);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(locationsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"timestamp\", \"asc\"));\n        const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const locations = [];\n        snapshot.forEach((doc)=>{\n            const data = doc.data();\n            locations.push({\n                id: doc.id,\n                latitude: data.latitude,\n                longitude: data.longitude,\n                timestamp: data.timestamp instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp ? data.timestamp.toDate() : new Date(data.timestamp),\n                speed: data.speed,\n                accuracy: data.accuracy\n            });\n        });\n        return locations;\n    } catch (error) {\n        console.error(\"[v0] Error getting locations from collection:\", error);\n        return [];\n    }\n}\nasync function saveRouteAsActive(routeId, locations) {\n    try {\n        const points = locations.map((loc)=>({\n                lat: loc.latitude,\n                lng: loc.longitude,\n                timestamp: loc.timestamp instanceof Date ? loc.timestamp.toISOString() : loc.timestamp\n            }));\n        const deduplicated = (0,_utils_simplify_route__WEBPACK_IMPORTED_MODULE_2__.removeDuplicatePoints)(points);\n        console.log(\"[v0] Step 1 - Deduplication: \".concat(points.length, \" → \").concat(deduplicated.length, \" points\"));\n        const snapped = await (0,_utils_simplify_route__WEBPACK_IMPORTED_MODULE_2__.snapToRoads)(deduplicated);\n        let finalPoints;\n        if (snapped) {\n            console.log(\"[v0] Step 2 - Road snapping successful: \".concat(snapped.length, \" points\"));\n            finalPoints = snapped;\n        } else {\n            console.log(\"[v0] Step 2 - Road snapping failed, using Douglas-Peucker instead\");\n            const simplified = (0,_utils_simplify_route__WEBPACK_IMPORTED_MODULE_2__.simplifyRoute)(deduplicated, 0.0001);\n            console.log(\"[v0] Step 2 - Simplification: \".concat(deduplicated.length, \" → \").concat(simplified.length, \" points\"));\n            finalPoints = simplified;\n        }\n        // Save route data to /saved-routes/{routeId}\n        const routeDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"saved-routes\", routeId);\n        const savedRoute = {\n            name: \"\".concat(routeId, \"のルート\"),\n            createdAt: new Date().toISOString(),\n            points: finalPoints\n        };\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(routeDocRef, savedRoute);\n        // Update /settings/active-route to point to this route\n        const settingsDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"settings\", \"active-route\");\n        const activeSettings = {\n            routeId: routeId,\n            updatedAt: new Date().toISOString()\n        };\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(settingsDocRef, activeSettings);\n        return true;\n    } catch (error) {\n        console.error(\"[v0] Error saving route:\", error);\n        return false;\n    }\n}\nasync function saveCustomRoute(routeId, points, options) {\n    try {\n        const routeDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"saved-routes\", routeId);\n        const savedRoute = {\n            name: (options === null || options === void 0 ? void 0 : options.name) || \"\".concat(routeId, \"のルート\"),\n            createdAt: new Date().toISOString(),\n            points: points.map((param)=>{\n                let [lat, lng] = param;\n                return {\n                    lat,\n                    lng\n                };\n            })\n        };\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(routeDocRef, savedRoute);\n        return true;\n    } catch (error) {\n        console.error(\"[v0] Error saving custom route:\", error);\n        return false;\n    }\n}\nasync function saveMonthSchedule(yearMonth, schedule) {\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"schedules\", yearMonth);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(docRef, {\n            yearMonth,\n            days: schedule,\n            updatedAt: new Date().toISOString()\n        });\n        return true;\n    } catch (error) {\n        console.error(\"[v0] Error saving schedule:\", error);\n        return false;\n    }\n}\nasync function getMonthSchedule(yearMonth) {\n    try {\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"schedules\", yearMonth);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(docRef);\n        if (docSnap.exists()) {\n            const data = docSnap.data();\n            const schedule = data.days;\n            // 後方互換性: 単一のDayScheduleを配列に変換\n            const normalized = {};\n            for (const [dateStr, daySchedule] of Object.entries(schedule)){\n                if (Array.isArray(daySchedule)) {\n                    normalized[dateStr] = daySchedule;\n                } else {\n                    normalized[dateStr] = [\n                        daySchedule\n                    ];\n                }\n            }\n            return normalized;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"[v0] Error getting schedule:\", error);\n        return null;\n    }\n}\nasync function getCurrentScheduleStatus() {\n    try {\n        const now = new Date();\n        const yearMonth = \"\".concat(now.getFullYear(), \"-\").concat(String(now.getMonth() + 1).padStart(2, \"0\"));\n        const dateStr = \"\".concat(now.getFullYear(), \"-\").concat(String(now.getMonth() + 1).padStart(2, \"0\"), \"-\").concat(String(now.getDate()).padStart(2, \"0\"));\n        const schedule = await getMonthSchedule(yearMonth);\n        if (!schedule || !schedule[dateStr]) {\n            const nextOp = await findNextOperation(now);\n            return {\n                isOperating: false,\n                schedule: null,\n                nextOperation: nextOp\n            };\n        }\n        const daySchedules = Array.isArray(schedule[dateStr]) ? schedule[dateStr] : [\n            schedule[dateStr]\n        ];\n        const currentTime = \"\".concat(String(now.getHours()).padStart(2, \"0\"), \":\").concat(String(now.getMinutes()).padStart(2, \"0\"));\n        // 現在の時間に該当するスケジュールを探す\n        const activeSchedule = daySchedules.find((s)=>s.isOperating && currentTime >= s.startTime && currentTime <= s.endTime);\n        if (activeSchedule) {\n            return {\n                isOperating: true,\n                schedule: activeSchedule\n            };\n        }\n        // 運行中ではない場合、次回の運行を探す\n        const nextOp = await findNextOperation(now);\n        return {\n            isOperating: false,\n            schedule: daySchedules[0] || null,\n            nextOperation: nextOp\n        };\n    } catch (error) {\n        console.error(\"[v0] Error getting current schedule status:\", error);\n        return null;\n    }\n}\nasync function findNextOperation(fromDate) {\n    try {\n        const dayNames = [\n            \"日\",\n            \"月\",\n            \"火\",\n            \"水\",\n            \"木\",\n            \"金\",\n            \"土\"\n        ];\n        // 今日から30日後まで検索\n        for(let i = 0; i < 30; i++){\n            const checkDate = new Date(fromDate);\n            checkDate.setDate(checkDate.getDate() + i);\n            const yearMonth = \"\".concat(checkDate.getFullYear(), \"-\").concat(String(checkDate.getMonth() + 1).padStart(2, \"0\"));\n            const dateStr = \"\".concat(checkDate.getFullYear(), \"-\").concat(String(checkDate.getMonth() + 1).padStart(2, \"0\"), \"-\").concat(String(checkDate.getDate()).padStart(2, \"0\"));\n            const schedule = await getMonthSchedule(yearMonth);\n            if (!schedule || !schedule[dateStr]) continue;\n            const daySchedules = Array.isArray(schedule[dateStr]) ? schedule[dateStr] : [\n                schedule[dateStr]\n            ];\n            const operatingSchedules = daySchedules.filter((s)=>s.isOperating);\n            if (operatingSchedules.length === 0) continue;\n            const currentTime = \"\".concat(String(fromDate.getHours()).padStart(2, \"0\"), \":\").concat(String(fromDate.getMinutes()).padStart(2, \"0\"));\n            // 同日の場合は、運行開始時刻が現在時刻より後のスケジュールを探す\n            if (i === 0) {\n                const futureSchedules = operatingSchedules.filter((s)=>s.startTime > currentTime);\n                if (futureSchedules.length > 0) {\n                    // 最も近い未来のスケジュールを選択\n                    const nextSchedule = futureSchedules.sort((a, b)=>a.startTime.localeCompare(b.startTime))[0];\n                    return {\n                        date: \"\".concat(checkDate.getMonth() + 1, \"/\").concat(checkDate.getDate()),\n                        dayOfWeek: dayNames[checkDate.getDay()],\n                        startTime: nextSchedule.startTime,\n                        endTime: nextSchedule.endTime,\n                        startLocation: nextSchedule.startLocation || \"ヤンマー前\",\n                        routeType: nextSchedule.routeType\n                    };\n                }\n                continue;\n            }\n            // 他の日の場合は、最初のスケジュールを返す\n            const firstSchedule = operatingSchedules.sort((a, b)=>a.startTime.localeCompare(b.startTime))[0];\n            return {\n                date: \"\".concat(checkDate.getMonth() + 1, \"/\").concat(checkDate.getDate()),\n                dayOfWeek: dayNames[checkDate.getDay()],\n                startTime: firstSchedule.startTime,\n                endTime: firstSchedule.endTime,\n                startLocation: firstSchedule.startLocation || \"ヤンマー前\",\n                routeType: firstSchedule.routeType\n            };\n        }\n        return undefined;\n    } catch (error) {\n        console.error(\"[v0] Error finding next operation:\", error);\n        return undefined;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9maXJlYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBWTFCO0FBRStEO0FBRTFGLE1BQU1lLGlCQUFpQjtJQUNyQkMsUUFBUUMseUNBQXdDO0lBQ2hERyxZQUFZSCw4QkFBNEM7SUFDeERLLFdBQVdMLGNBQTJDO0lBQ3RETyxlQUFlUCxrQ0FBK0M7SUFDOURTLG1CQUFtQlQsYUFBb0Q7SUFDdkVXLE9BQU9YLDBDQUF1QztJQUM5Q2EsZUFBZWIsY0FBK0M7QUFDaEU7QUFFQSwwQ0FBMEM7QUFDMUMsTUFBTWUsTUFBTS9CLHFEQUFPQSxHQUFHZ0MsTUFBTSxLQUFLLElBQUlqQywyREFBYUEsQ0FBQ2Usa0JBQWtCZCxxREFBT0EsRUFBRSxDQUFDLEVBQUU7QUFDakYsTUFBTWlDLEtBQUtoQyxnRUFBWUEsQ0FBQzhCO0FBRU47QUFFWCxTQUFTRyxxQkFDZEMsY0FBc0IsRUFDdEJDLFFBQTZDO0lBRTdDLE1BQU1DLGVBQWVuQyw4REFBVUEsQ0FBQytCLElBQUlFO0lBQ3BDLE1BQU1HLElBQUluQyx5REFBS0EsQ0FBQ2tDLGNBQWNqQywyREFBT0EsQ0FBQyxhQUFhO0lBRW5ELE1BQU1tQyxjQUFjbEMsOERBQVVBLENBQzVCaUMsR0FDQSxDQUFDRTtRQUNDLE1BQU1DLFlBQTRCLEVBQUU7UUFDcENELFNBQVNFLE9BQU8sQ0FBQyxDQUFDbkM7WUFDaEIsTUFBTW9DLE9BQU9wQyxJQUFJb0MsSUFBSTtZQUNyQkYsVUFBVUcsSUFBSSxDQUFDO2dCQUNiQyxJQUFJdEMsSUFBSXNDLEVBQUU7Z0JBQ1ZDLFVBQVVILEtBQUtHLFFBQVE7Z0JBQ3ZCQyxXQUFXSixLQUFLSSxTQUFTO2dCQUN6QkMsV0FBV0wsS0FBS0ssU0FBUyxZQUFZMUMseURBQVNBLEdBQUdxQyxLQUFLSyxTQUFTLENBQUNDLE1BQU0sS0FBSyxJQUFJQyxLQUFLUCxLQUFLSyxTQUFTO2dCQUNsR0csT0FBT1IsS0FBS1EsS0FBSztnQkFDakJDLFVBQVVULEtBQUtTLFFBQVE7WUFDekI7UUFDRjtRQUNBaEIsU0FBU0s7SUFDWCxHQUNBLENBQUNZO1FBQ0NDLFFBQVFELEtBQUssQ0FBQyx5QkFBeUJBO0lBQ3pDO0lBR0YsT0FBT2Q7QUFDVDtBQUVPLGVBQWVnQjtJQUNwQixJQUFJO1FBQ0YsTUFBTUMsU0FBU2pELHVEQUFHQSxDQUFDMEIsSUFBSSxZQUFZO1FBQ25DLE1BQU13QixVQUFVLE1BQU1qRCwwREFBTUEsQ0FBQ2dEO1FBRTdCLElBQUlDLFFBQVFDLE1BQU0sSUFBSTtZQUNwQixNQUFNZixPQUFPYyxRQUFRZCxJQUFJO1lBQ3pCLE9BQU9BLEtBQUtnQixPQUFPO1FBQ3JCO1FBQ0EsT0FBTztJQUNULEVBQUUsT0FBT04sT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLGVBQWVPLGNBQWNELE9BQWU7SUFDakQsSUFBSTtRQUNGLE1BQU1ILFNBQVNqRCx1REFBR0EsQ0FBQzBCLElBQUksZ0JBQWdCMEI7UUFDdkMsTUFBTUYsVUFBVSxNQUFNakQsMERBQU1BLENBQUNnRDtRQUU3QixJQUFJQyxRQUFRQyxNQUFNLElBQUk7WUFDcEIsT0FBT0QsUUFBUWQsSUFBSTtRQUNyQjtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9VLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlUTtJQUNwQixJQUFJO1FBQ0YsTUFBTUMsWUFBWTVELDhEQUFVQSxDQUFDK0IsSUFBSTtRQUNqQyxNQUFNTyxXQUFXLE1BQU0vQiwyREFBT0EsQ0FBQ3FEO1FBQy9CLE9BQU90QixTQUFTdUIsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQ1A7Z0JBS1ZkO1lBSmQsTUFBTUEsT0FBT2MsUUFBUWQsSUFBSTtZQUN6QixPQUFPO2dCQUNMRSxJQUFJWSxRQUFRWixFQUFFO2dCQUNkb0IsTUFBTXRCLEtBQUtzQixJQUFJLElBQUlSLFFBQVFaLEVBQUU7Z0JBQzdCcUIsWUFBWXZCLEVBQUFBLGVBQUFBLEtBQUt3QixNQUFNLGNBQVh4QixtQ0FBQUEsYUFBYVgsTUFBTSxLQUFJO1lBQ3JDO1FBQ0Y7SUFDRixFQUFFLE9BQU9xQixPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFTyxlQUFlZTtJQUNwQixJQUFJO1FBQ0YsTUFBTVosU0FBU2pELHVEQUFHQSxDQUFDMEIsSUFBSSxjQUFjO1FBQ3JDLE1BQU13QixVQUFVLE1BQU1qRCwwREFBTUEsQ0FBQ2dEO1FBRTdCLElBQUlDLFFBQVFDLE1BQU0sSUFBSTtZQUNwQixNQUFNZixPQUFPYyxRQUFRZCxJQUFJO1lBQ3pCLE1BQU0wQixXQUFXMUIsS0FBSzBCLFFBQVE7WUFFOUIseUNBQXlDO1lBQ3pDLE9BQU9BLFNBQVNDLElBQUksQ0FBQyxDQUFDQyxHQUFHQztnQkFDdkIsTUFBTUMsUUFBUUYsRUFBRUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM3QixNQUFNQyxRQUFRSCxFQUFFRSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzdCLE9BQU9DLE1BQU1DLGFBQWEsQ0FBQ0g7WUFDN0I7UUFDRjtRQUVBLE9BQU8sRUFBRTtJQUNYLEVBQUUsT0FBT3BCLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVPLGVBQWV3Qiw4QkFBOEIxQyxjQUFzQjtJQUN4RSxJQUFJO1FBQ0YsTUFBTUUsZUFBZW5DLDhEQUFVQSxDQUFDK0IsSUFBSUU7UUFDcEMsTUFBTUcsSUFBSW5DLHlEQUFLQSxDQUFDa0MsY0FBY2pDLDJEQUFPQSxDQUFDLGFBQWE7UUFDbkQsTUFBTW9DLFdBQVcsTUFBTS9CLDJEQUFPQSxDQUFDNkI7UUFFL0IsTUFBTUcsWUFBNEIsRUFBRTtRQUNwQ0QsU0FBU0UsT0FBTyxDQUFDLENBQUNuQztZQUNoQixNQUFNb0MsT0FBT3BDLElBQUlvQyxJQUFJO1lBQ3JCRixVQUFVRyxJQUFJLENBQUM7Z0JBQ2JDLElBQUl0QyxJQUFJc0MsRUFBRTtnQkFDVkMsVUFBVUgsS0FBS0csUUFBUTtnQkFDdkJDLFdBQVdKLEtBQUtJLFNBQVM7Z0JBQ3pCQyxXQUFXTCxLQUFLSyxTQUFTLFlBQVkxQyx5REFBU0EsR0FBR3FDLEtBQUtLLFNBQVMsQ0FBQ0MsTUFBTSxLQUFLLElBQUlDLEtBQUtQLEtBQUtLLFNBQVM7Z0JBQ2xHRyxPQUFPUixLQUFLUSxLQUFLO2dCQUNqQkMsVUFBVVQsS0FBS1MsUUFBUTtZQUN6QjtRQUNGO1FBRUEsT0FBT1g7SUFDVCxFQUFFLE9BQU9ZLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlEQUFpREE7UUFDL0QsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVPLGVBQWV5QixrQkFBa0JuQixPQUFlLEVBQUVsQixTQUF5QjtJQUNoRixJQUFJO1FBQ0YsTUFBTTBCLFNBQVMxQixVQUFVdUIsR0FBRyxDQUFDLENBQUNlLE1BQVM7Z0JBQ3JDQyxLQUFLRCxJQUFJakMsUUFBUTtnQkFDakJtQyxLQUFLRixJQUFJaEMsU0FBUztnQkFDbEJDLFdBQVcrQixJQUFJL0IsU0FBUyxZQUFZRSxPQUFPNkIsSUFBSS9CLFNBQVMsQ0FBQ2tDLFdBQVcsS0FBS0gsSUFBSS9CLFNBQVM7WUFDeEY7UUFFQSxNQUFNbUMsZUFBZXZFLDRFQUFxQkEsQ0FBQ3VEO1FBQzNDYixRQUFROEIsR0FBRyxDQUFDLGdDQUFtREQsT0FBbkJoQixPQUFPbkMsTUFBTSxFQUFDLE9BQXlCLE9BQXBCbUQsYUFBYW5ELE1BQU0sRUFBQztRQUVuRixNQUFNcUQsVUFBVSxNQUFNeEUsa0VBQVdBLENBQUNzRTtRQUVsQyxJQUFJRztRQUVKLElBQUlELFNBQVM7WUFDWC9CLFFBQVE4QixHQUFHLENBQUMsMkNBQTBELE9BQWZDLFFBQVFyRCxNQUFNLEVBQUM7WUFDdEVzRCxjQUFjRDtRQUNoQixPQUFPO1lBQ0wvQixRQUFROEIsR0FBRyxDQUFDO1lBQ1osTUFBTUcsYUFBYTVFLG9FQUFhQSxDQUFDd0UsY0FBYztZQUMvQzdCLFFBQVE4QixHQUFHLENBQUMsaUNBQTBERyxPQUF6QkosYUFBYW5ELE1BQU0sRUFBQyxPQUF1QixPQUFsQnVELFdBQVd2RCxNQUFNLEVBQUM7WUFDeEZzRCxjQUFjQztRQUNoQjtRQUVBLDZDQUE2QztRQUM3QyxNQUFNQyxjQUFjakYsdURBQUdBLENBQUMwQixJQUFJLGdCQUFnQjBCO1FBQzVDLE1BQU04QixhQUF5QjtZQUM3QnhCLE1BQU0sR0FBVyxPQUFSTixTQUFRO1lBQ2pCK0IsV0FBVyxJQUFJeEMsT0FBT2dDLFdBQVc7WUFDakNmLFFBQVFtQjtRQUNWO1FBQ0EsTUFBTTVFLDBEQUFNQSxDQUFDOEUsYUFBYUM7UUFFMUIsdURBQXVEO1FBQ3ZELE1BQU1FLGlCQUFpQnBGLHVEQUFHQSxDQUFDMEIsSUFBSSxZQUFZO1FBQzNDLE1BQU0yRCxpQkFBc0M7WUFDMUNqQyxTQUFTQTtZQUNUa0MsV0FBVyxJQUFJM0MsT0FBT2dDLFdBQVc7UUFDbkM7UUFDQSxNQUFNeEUsMERBQU1BLENBQUNpRixnQkFBZ0JDO1FBRTdCLE9BQU87SUFDVCxFQUFFLE9BQU92QyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87SUFDVDtBQUNGO0FBRU8sZUFBZXlDLGdCQUNwQm5DLE9BQWUsRUFDZlEsTUFBMEIsRUFDMUI0QixPQUEyQjtJQUUzQixJQUFJO1FBQ0YsTUFBTVAsY0FBY2pGLHVEQUFHQSxDQUFDMEIsSUFBSSxnQkFBZ0IwQjtRQUM1QyxNQUFNOEIsYUFBeUI7WUFDN0J4QixNQUFNOEIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTOUIsSUFBSSxLQUFJLEdBQVcsT0FBUk4sU0FBUTtZQUNsQytCLFdBQVcsSUFBSXhDLE9BQU9nQyxXQUFXO1lBQ2pDZixRQUFRQSxPQUFPSCxHQUFHLENBQUM7b0JBQUMsQ0FBQ2dCLEtBQUtDLElBQUk7dUJBQU07b0JBQUVEO29CQUFLQztnQkFBSTs7UUFDakQ7UUFDQSxNQUFNdkUsMERBQU1BLENBQUM4RSxhQUFhQztRQUMxQixPQUFPO0lBQ1QsRUFBRSxPQUFPcEMsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtRQUNqRCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLGVBQWUyQyxrQkFBa0JDLFNBQWlCLEVBQUVDLFFBQXVCO0lBQ2hGLElBQUk7UUFDRixNQUFNMUMsU0FBU2pELHVEQUFHQSxDQUFDMEIsSUFBSSxhQUFhZ0U7UUFDcEMsTUFBTXZGLDBEQUFNQSxDQUFDOEMsUUFBUTtZQUNuQnlDO1lBQ0FFLE1BQU1EO1lBQ05MLFdBQVcsSUFBSTNDLE9BQU9nQyxXQUFXO1FBQ25DO1FBQ0EsT0FBTztJQUNULEVBQUUsT0FBTzdCLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlK0MsaUJBQWlCSCxTQUFpQjtJQUN0RCxJQUFJO1FBQ0YsTUFBTXpDLFNBQVNqRCx1REFBR0EsQ0FBQzBCLElBQUksYUFBYWdFO1FBQ3BDLE1BQU14QyxVQUFVLE1BQU1qRCwwREFBTUEsQ0FBQ2dEO1FBRTdCLElBQUlDLFFBQVFDLE1BQU0sSUFBSTtZQUNwQixNQUFNZixPQUFPYyxRQUFRZCxJQUFJO1lBQ3pCLE1BQU11RCxXQUFXdkQsS0FBS3dELElBQUk7WUFDMUIsOEJBQThCO1lBQzlCLE1BQU1FLGFBQTRCLENBQUM7WUFDbkMsS0FBSyxNQUFNLENBQUNDLFNBQVNDLFlBQVksSUFBSUMsT0FBT0MsT0FBTyxDQUFDUCxVQUFXO2dCQUM3RCxJQUFJUSxNQUFNQyxPQUFPLENBQUNKLGNBQWM7b0JBQzlCRixVQUFVLENBQUNDLFFBQVEsR0FBR0M7Z0JBQ3hCLE9BQU87b0JBQ0xGLFVBQVUsQ0FBQ0MsUUFBUSxHQUFHO3dCQUFDQztxQkFBWTtnQkFDckM7WUFDRjtZQUNBLE9BQU9GO1FBQ1Q7UUFDQSxPQUFPO0lBQ1QsRUFBRSxPQUFPaEQsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxPQUFPO0lBQ1Q7QUFDRjtBQUVPLGVBQWV1RDtJQVlwQixJQUFJO1FBQ0YsTUFBTUMsTUFBTSxJQUFJM0Q7UUFDaEIsTUFBTStDLFlBQVksR0FBd0JhLE9BQXJCRCxJQUFJRSxXQUFXLElBQUcsS0FBK0MsT0FBNUNELE9BQU9ELElBQUlHLFFBQVEsS0FBSyxHQUFHQyxRQUFRLENBQUMsR0FBRztRQUNqRixNQUFNWCxVQUFVLEdBQXdCUSxPQUFyQkQsSUFBSUUsV0FBVyxJQUFHLEtBQWtERCxPQUEvQ0EsT0FBT0QsSUFBSUcsUUFBUSxLQUFLLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBMEMsT0FBdkNILE9BQU9ELElBQUlLLE9BQU8sSUFBSUQsUUFBUSxDQUFDLEdBQUc7UUFFekgsTUFBTWYsV0FBVyxNQUFNRSxpQkFBaUJIO1FBQ3hDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQSxRQUFRLENBQUNJLFFBQVEsRUFBRTtZQUNuQyxNQUFNYSxTQUFTLE1BQU1DLGtCQUFrQlA7WUFDdkMsT0FBTztnQkFBRVEsYUFBYTtnQkFBT25CLFVBQVU7Z0JBQU1vQixlQUFlSDtZQUFPO1FBQ3JFO1FBRUEsTUFBTUksZUFBZWIsTUFBTUMsT0FBTyxDQUFDVCxRQUFRLENBQUNJLFFBQVEsSUFBSUosUUFBUSxDQUFDSSxRQUFRLEdBQUc7WUFBQ0osUUFBUSxDQUFDSSxRQUFRO1NBQUM7UUFDL0YsTUFBTWtCLGNBQWMsR0FBOENWLE9BQTNDQSxPQUFPRCxJQUFJWSxRQUFRLElBQUlSLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBNkMsT0FBMUNILE9BQU9ELElBQUlhLFVBQVUsSUFBSVQsUUFBUSxDQUFDLEdBQUc7UUFFdkcsc0JBQXNCO1FBQ3RCLE1BQU1VLGlCQUFpQkosYUFBYUssSUFBSSxDQUN0QyxDQUFDQyxJQUFNQSxFQUFFUixXQUFXLElBQUlHLGVBQWVLLEVBQUVDLFNBQVMsSUFBSU4sZUFBZUssRUFBRUUsT0FBTztRQUdoRixJQUFJSixnQkFBZ0I7WUFDbEIsT0FBTztnQkFBRU4sYUFBYTtnQkFBTW5CLFVBQVV5QjtZQUFlO1FBQ3ZEO1FBRUEscUJBQXFCO1FBQ3JCLE1BQU1SLFNBQVMsTUFBTUMsa0JBQWtCUDtRQUN2QyxPQUFPO1lBQUVRLGFBQWE7WUFBT25CLFVBQVVxQixZQUFZLENBQUMsRUFBRSxJQUFJO1lBQU1ELGVBQWVIO1FBQU87SUFDeEYsRUFBRSxPQUFPOUQsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0NBQStDQTtRQUM3RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGVBQWUrRCxrQkFBa0JZLFFBQWM7SUFXN0MsSUFBSTtRQUNGLE1BQU1DLFdBQVc7WUFBQztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBRXBELGVBQWU7UUFDZixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQzNCLE1BQU1DLFlBQVksSUFBSWpGLEtBQUs4RTtZQUMzQkcsVUFBVUMsT0FBTyxDQUFDRCxVQUFVakIsT0FBTyxLQUFLZ0I7WUFFeEMsTUFBTWpDLFlBQVksR0FBOEJhLE9BQTNCcUIsVUFBVXBCLFdBQVcsSUFBRyxLQUFxRCxPQUFsREQsT0FBT3FCLFVBQVVuQixRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUc7WUFDN0YsTUFBTVgsVUFBVSxHQUE4QlEsT0FBM0JxQixVQUFVcEIsV0FBVyxJQUFHLEtBQXdERCxPQUFyREEsT0FBT3FCLFVBQVVuQixRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUFnRCxPQUE3Q0gsT0FBT3FCLFVBQVVqQixPQUFPLElBQUlELFFBQVEsQ0FBQyxHQUFHO1lBRTNJLE1BQU1mLFdBQVcsTUFBTUUsaUJBQWlCSDtZQUN4QyxJQUFJLENBQUNDLFlBQVksQ0FBQ0EsUUFBUSxDQUFDSSxRQUFRLEVBQUU7WUFFckMsTUFBTWlCLGVBQWViLE1BQU1DLE9BQU8sQ0FBQ1QsUUFBUSxDQUFDSSxRQUFRLElBQUlKLFFBQVEsQ0FBQ0ksUUFBUSxHQUFHO2dCQUFDSixRQUFRLENBQUNJLFFBQVE7YUFBQztZQUMvRixNQUFNK0IscUJBQXFCZCxhQUFhZSxNQUFNLENBQUMsQ0FBQ1QsSUFBTUEsRUFBRVIsV0FBVztZQUVuRSxJQUFJZ0IsbUJBQW1CckcsTUFBTSxLQUFLLEdBQUc7WUFFckMsTUFBTXdGLGNBQWMsR0FBbURWLE9BQWhEQSxPQUFPa0IsU0FBU1AsUUFBUSxJQUFJUixRQUFRLENBQUMsR0FBRyxNQUFLLEtBQWtELE9BQS9DSCxPQUFPa0IsU0FBU04sVUFBVSxJQUFJVCxRQUFRLENBQUMsR0FBRztZQUVqSCxrQ0FBa0M7WUFDbEMsSUFBSWlCLE1BQU0sR0FBRztnQkFDWCxNQUFNSyxrQkFBa0JGLG1CQUFtQkMsTUFBTSxDQUFDLENBQUNULElBQU1BLEVBQUVDLFNBQVMsR0FBR047Z0JBQ3ZFLElBQUllLGdCQUFnQnZHLE1BQU0sR0FBRyxHQUFHO29CQUM5QixtQkFBbUI7b0JBQ25CLE1BQU13RyxlQUFlRCxnQkFBZ0JqRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRXVELFNBQVMsQ0FBQ2xELGFBQWEsQ0FBQ0osRUFBRXNELFNBQVMsRUFBRSxDQUFDLEVBQUU7b0JBQzlGLE9BQU87d0JBQ0xXLE1BQU0sR0FBK0JOLE9BQTVCQSxVQUFVbkIsUUFBUSxLQUFLLEdBQUUsS0FBdUIsT0FBcEJtQixVQUFVakIsT0FBTzt3QkFDdER3QixXQUFXVCxRQUFRLENBQUNFLFVBQVVRLE1BQU0sR0FBRzt3QkFDdkNiLFdBQVdVLGFBQWFWLFNBQVM7d0JBQ2pDQyxTQUFTUyxhQUFhVCxPQUFPO3dCQUM3QmEsZUFBZUosYUFBYUksYUFBYSxJQUFJO3dCQUM3Q0MsV0FBV0wsYUFBYUssU0FBUztvQkFDbkM7Z0JBQ0Y7Z0JBRUE7WUFDRjtZQUVBLHVCQUF1QjtZQUN2QixNQUFNQyxnQkFBZ0JULG1CQUFtQi9ELElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFdUQsU0FBUyxDQUFDbEQsYUFBYSxDQUFDSixFQUFFc0QsU0FBUyxFQUFFLENBQUMsRUFBRTtZQUNsRyxPQUFPO2dCQUNMVyxNQUFNLEdBQStCTixPQUE1QkEsVUFBVW5CLFFBQVEsS0FBSyxHQUFFLEtBQXVCLE9BQXBCbUIsVUFBVWpCLE9BQU87Z0JBQ3REd0IsV0FBV1QsUUFBUSxDQUFDRSxVQUFVUSxNQUFNLEdBQUc7Z0JBQ3ZDYixXQUFXZ0IsY0FBY2hCLFNBQVM7Z0JBQ2xDQyxTQUFTZSxjQUFjZixPQUFPO2dCQUM5QmEsZUFBZUUsY0FBY0YsYUFBYSxJQUFJO2dCQUM5Q0MsV0FBV0MsY0FBY0QsU0FBUztZQUNwQztRQUNGO1FBRUEsT0FBT0U7SUFDVCxFQUFFLE9BQU8xRixPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE9BQU8wRjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWRtaW5cXERvY3VtZW50c1xcbXktYXBwXFxsaWJcXGZpcmViYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMgfSBmcm9tIFwiZmlyZWJhc2UvYXBwXCJcclxuaW1wb3J0IHtcclxuICBnZXRGaXJlc3RvcmUsXHJcbiAgY29sbGVjdGlvbixcclxuICBxdWVyeSxcclxuICBvcmRlckJ5LFxyXG4gIG9uU25hcHNob3QsXHJcbiAgVGltZXN0YW1wLFxyXG4gIGRvYyxcclxuICBnZXREb2MsXHJcbiAgZ2V0RG9jcyxcclxuICBzZXREb2MsXHJcbn0gZnJvbSBcImZpcmViYXNlL2ZpcmVzdG9yZVwiXHJcbmltcG9ydCB0eXBlIHsgTG9jYXRpb25EYXRhLCBTYXZlZFJvdXRlLCBBY3RpdmVSb3V0ZVNldHRpbmdzLCBEYXlTY2hlZHVsZSwgTW9udGhTY2hlZHVsZSB9IGZyb20gXCIuL3R5cGVzXCJcclxuaW1wb3J0IHsgc2ltcGxpZnlSb3V0ZSwgcmVtb3ZlRHVwbGljYXRlUG9pbnRzLCBzbmFwVG9Sb2FkcyB9IGZyb20gXCIuL3V0aWxzL3NpbXBsaWZ5LXJvdXRlXCJcclxuXHJcbmNvbnN0IGZpcmViYXNlQ29uZmlnID0ge1xyXG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSxcclxuICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTixcclxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQsXHJcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQsXHJcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQsXHJcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCxcclxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCxcclxufVxyXG5cclxuLy8gSW5pdGlhbGl6ZSBGaXJlYmFzZSAoc2luZ2xldG9uIHBhdHRlcm4pXHJcbmNvbnN0IGFwcCA9IGdldEFwcHMoKS5sZW5ndGggPT09IDAgPyBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKSA6IGdldEFwcHMoKVswXVxyXG5jb25zdCBkYiA9IGdldEZpcmVzdG9yZShhcHApXHJcblxyXG5leHBvcnQgeyBhcHAsIGRiIH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWFsdGltZUxvY2F0aW9ucyhcclxuICBjb2xsZWN0aW9uTmFtZTogc3RyaW5nLFxyXG4gIGNhbGxiYWNrOiAobG9jYXRpb25zOiBMb2NhdGlvbkRhdGFbXSkgPT4gdm9pZCxcclxuKTogKCkgPT4gdm9pZCB7XHJcbiAgY29uc3QgbG9jYXRpb25zUmVmID0gY29sbGVjdGlvbihkYiwgY29sbGVjdGlvbk5hbWUpXHJcbiAgY29uc3QgcSA9IHF1ZXJ5KGxvY2F0aW9uc1JlZiwgb3JkZXJCeShcInRpbWVzdGFtcFwiLCBcImFzY1wiKSlcclxuXHJcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBvblNuYXBzaG90KFxyXG4gICAgcSxcclxuICAgIChzbmFwc2hvdCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2NhdGlvbnM6IExvY2F0aW9uRGF0YVtdID0gW11cclxuICAgICAgc25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKClcclxuICAgICAgICBsb2NhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgICAgbGF0aXR1ZGU6IGRhdGEubGF0aXR1ZGUsXHJcbiAgICAgICAgICBsb25naXR1ZGU6IGRhdGEubG9uZ2l0dWRlLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCBpbnN0YW5jZW9mIFRpbWVzdGFtcCA/IGRhdGEudGltZXN0YW1wLnRvRGF0ZSgpIDogbmV3IERhdGUoZGF0YS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgc3BlZWQ6IGRhdGEuc3BlZWQsXHJcbiAgICAgICAgICBhY2N1cmFjeTogZGF0YS5hY2N1cmFjeSxcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgICBjYWxsYmFjayhsb2NhdGlvbnMpXHJcbiAgICB9LFxyXG4gICAgKGVycm9yKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEZpcmVzdG9yZSBlcnJvcjpcIiwgZXJyb3IpXHJcbiAgICB9LFxyXG4gIClcclxuXHJcbiAgcmV0dXJuIHVuc3Vic2NyaWJlXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY3RpdmVSb3V0ZSgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZG9jUmVmID0gZG9jKGRiLCBcInNldHRpbmdzXCIsIFwiYWN0aXZlLXJvdXRlXCIpXHJcbiAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZilcclxuXHJcbiAgICBpZiAoZG9jU25hcC5leGlzdHMoKSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gZG9jU25hcC5kYXRhKCkgYXMgQWN0aXZlUm91dGVTZXR0aW5nc1xyXG4gICAgICByZXR1cm4gZGF0YS5yb3V0ZUlkXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBnZXR0aW5nIGFjdGl2ZSByb3V0ZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNhdmVkUm91dGUocm91dGVJZDogc3RyaW5nKTogUHJvbWlzZTxTYXZlZFJvdXRlIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsIFwic2F2ZWQtcm91dGVzXCIsIHJvdXRlSWQpXHJcbiAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZilcclxuXHJcbiAgICBpZiAoZG9jU25hcC5leGlzdHMoKSkge1xyXG4gICAgICByZXR1cm4gZG9jU25hcC5kYXRhKCkgYXMgU2F2ZWRSb3V0ZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgZ2V0dGluZyBzYXZlZCByb3V0ZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNhdmVkUm91dGVzKCk6IFByb21pc2U8eyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHBvaW50Q291bnQ6IG51bWJlciB9W10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgcm91dGVzUmVmID0gY29sbGVjdGlvbihkYiwgXCJzYXZlZC1yb3V0ZXNcIilcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhyb3V0ZXNSZWYpXHJcbiAgICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoKGRvY1NuYXApID0+IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGRvY1NuYXAuZGF0YSgpIGFzIFNhdmVkUm91dGVcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogZG9jU25hcC5pZCxcclxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUgfHwgZG9jU25hcC5pZCxcclxuICAgICAgICBwb2ludENvdW50OiBkYXRhLnBvaW50cz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIGxpc3Rpbmcgc2F2ZWQgcm91dGVzOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERhdGVDb2xsZWN0aW9ucygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgXCJkYXRlLWluZGV4XCIsIFwiZGF0ZXNcIilcclxuICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBnZXREb2MoZG9jUmVmKVxyXG5cclxuICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2NTbmFwLmRhdGEoKVxyXG4gICAgICBjb25zdCBkYXRlTGlzdCA9IGRhdGEuZGF0ZUxpc3QgYXMgc3RyaW5nW11cclxuXHJcbiAgICAgIC8vIFNvcnQgYnkgZGF0ZSBkZXNjZW5kaW5nIChuZXdlc3QgZmlyc3QpXHJcbiAgICAgIHJldHVybiBkYXRlTGlzdC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0ZUEgPSBhLnNwbGl0KFwiX1wiKVswXVxyXG4gICAgICAgIGNvbnN0IGRhdGVCID0gYi5zcGxpdChcIl9cIilbMF1cclxuICAgICAgICByZXR1cm4gZGF0ZUIubG9jYWxlQ29tcGFyZShkYXRlQSlcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW11cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgZ2V0dGluZyBkYXRlIGluZGV4OlwiLCBlcnJvcilcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbExvY2F0aW9uc0Zyb21Db2xsZWN0aW9uKGNvbGxlY3Rpb25OYW1lOiBzdHJpbmcpOiBQcm9taXNlPExvY2F0aW9uRGF0YVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGxvY2F0aW9uc1JlZiA9IGNvbGxlY3Rpb24oZGIsIGNvbGxlY3Rpb25OYW1lKVxyXG4gICAgY29uc3QgcSA9IHF1ZXJ5KGxvY2F0aW9uc1JlZiwgb3JkZXJCeShcInRpbWVzdGFtcFwiLCBcImFzY1wiKSlcclxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxyXG5cclxuICAgIGNvbnN0IGxvY2F0aW9uczogTG9jYXRpb25EYXRhW10gPSBbXVxyXG4gICAgc25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpXHJcbiAgICAgIGxvY2F0aW9ucy5wdXNoKHtcclxuICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgIGxhdGl0dWRlOiBkYXRhLmxhdGl0dWRlLFxyXG4gICAgICAgIGxvbmdpdHVkZTogZGF0YS5sb25naXR1ZGUsXHJcbiAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCBpbnN0YW5jZW9mIFRpbWVzdGFtcCA/IGRhdGEudGltZXN0YW1wLnRvRGF0ZSgpIDogbmV3IERhdGUoZGF0YS50aW1lc3RhbXApLFxyXG4gICAgICAgIHNwZWVkOiBkYXRhLnNwZWVkLFxyXG4gICAgICAgIGFjY3VyYWN5OiBkYXRhLmFjY3VyYWN5LFxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gbG9jYXRpb25zXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIGdldHRpbmcgbG9jYXRpb25zIGZyb20gY29sbGVjdGlvbjpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlUm91dGVBc0FjdGl2ZShyb3V0ZUlkOiBzdHJpbmcsIGxvY2F0aW9uczogTG9jYXRpb25EYXRhW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcG9pbnRzID0gbG9jYXRpb25zLm1hcCgobG9jKSA9PiAoe1xyXG4gICAgICBsYXQ6IGxvYy5sYXRpdHVkZSxcclxuICAgICAgbG5nOiBsb2MubG9uZ2l0dWRlLFxyXG4gICAgICB0aW1lc3RhbXA6IGxvYy50aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlID8gbG9jLnRpbWVzdGFtcC50b0lTT1N0cmluZygpIDogbG9jLnRpbWVzdGFtcCxcclxuICAgIH0pKVxyXG5cclxuICAgIGNvbnN0IGRlZHVwbGljYXRlZCA9IHJlbW92ZUR1cGxpY2F0ZVBvaW50cyhwb2ludHMpXHJcbiAgICBjb25zb2xlLmxvZyhgW3YwXSBTdGVwIDEgLSBEZWR1cGxpY2F0aW9uOiAke3BvaW50cy5sZW5ndGh9IOKGkiAke2RlZHVwbGljYXRlZC5sZW5ndGh9IHBvaW50c2ApXHJcblxyXG4gICAgY29uc3Qgc25hcHBlZCA9IGF3YWl0IHNuYXBUb1JvYWRzKGRlZHVwbGljYXRlZClcclxuXHJcbiAgICBsZXQgZmluYWxQb2ludHM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH1bXVxyXG5cclxuICAgIGlmIChzbmFwcGVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBbdjBdIFN0ZXAgMiAtIFJvYWQgc25hcHBpbmcgc3VjY2Vzc2Z1bDogJHtzbmFwcGVkLmxlbmd0aH0gcG9pbnRzYClcclxuICAgICAgZmluYWxQb2ludHMgPSBzbmFwcGVkXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0gU3RlcCAyIC0gUm9hZCBzbmFwcGluZyBmYWlsZWQsIHVzaW5nIERvdWdsYXMtUGV1Y2tlciBpbnN0ZWFkXCIpXHJcbiAgICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBzaW1wbGlmeVJvdXRlKGRlZHVwbGljYXRlZCwgMC4wMDAxKVxyXG4gICAgICBjb25zb2xlLmxvZyhgW3YwXSBTdGVwIDIgLSBTaW1wbGlmaWNhdGlvbjogJHtkZWR1cGxpY2F0ZWQubGVuZ3RofSDihpIgJHtzaW1wbGlmaWVkLmxlbmd0aH0gcG9pbnRzYClcclxuICAgICAgZmluYWxQb2ludHMgPSBzaW1wbGlmaWVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2F2ZSByb3V0ZSBkYXRhIHRvIC9zYXZlZC1yb3V0ZXMve3JvdXRlSWR9XHJcbiAgICBjb25zdCByb3V0ZURvY1JlZiA9IGRvYyhkYiwgXCJzYXZlZC1yb3V0ZXNcIiwgcm91dGVJZClcclxuICAgIGNvbnN0IHNhdmVkUm91dGU6IFNhdmVkUm91dGUgPSB7XHJcbiAgICAgIG5hbWU6IGAke3JvdXRlSWR944Gu44Or44O844OIYCxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHBvaW50czogZmluYWxQb2ludHMsXHJcbiAgICB9XHJcbiAgICBhd2FpdCBzZXREb2Mocm91dGVEb2NSZWYsIHNhdmVkUm91dGUpXHJcblxyXG4gICAgLy8gVXBkYXRlIC9zZXR0aW5ncy9hY3RpdmUtcm91dGUgdG8gcG9pbnQgdG8gdGhpcyByb3V0ZVxyXG4gICAgY29uc3Qgc2V0dGluZ3NEb2NSZWYgPSBkb2MoZGIsIFwic2V0dGluZ3NcIiwgXCJhY3RpdmUtcm91dGVcIilcclxuICAgIGNvbnN0IGFjdGl2ZVNldHRpbmdzOiBBY3RpdmVSb3V0ZVNldHRpbmdzID0ge1xyXG4gICAgICByb3V0ZUlkOiByb3V0ZUlkLFxyXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH1cclxuICAgIGF3YWl0IHNldERvYyhzZXR0aW5nc0RvY1JlZiwgYWN0aXZlU2V0dGluZ3MpXHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3Igc2F2aW5nIHJvdXRlOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVDdXN0b21Sb3V0ZShcclxuICByb3V0ZUlkOiBzdHJpbmcsXHJcbiAgcG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10sXHJcbiAgb3B0aW9ucz86IHsgbmFtZT86IHN0cmluZyB9LFxyXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgcm91dGVEb2NSZWYgPSBkb2MoZGIsIFwic2F2ZWQtcm91dGVzXCIsIHJvdXRlSWQpXHJcbiAgICBjb25zdCBzYXZlZFJvdXRlOiBTYXZlZFJvdXRlID0ge1xyXG4gICAgICBuYW1lOiBvcHRpb25zPy5uYW1lIHx8IGAke3JvdXRlSWR944Gu44Or44O844OIYCxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHBvaW50czogcG9pbnRzLm1hcCgoW2xhdCwgbG5nXSkgPT4gKHsgbGF0LCBsbmcgfSkpLFxyXG4gICAgfVxyXG4gICAgYXdhaXQgc2V0RG9jKHJvdXRlRG9jUmVmLCBzYXZlZFJvdXRlKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3Igc2F2aW5nIGN1c3RvbSByb3V0ZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlTW9udGhTY2hlZHVsZSh5ZWFyTW9udGg6IHN0cmluZywgc2NoZWR1bGU6IE1vbnRoU2NoZWR1bGUpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZG9jUmVmID0gZG9jKGRiLCBcInNjaGVkdWxlc1wiLCB5ZWFyTW9udGgpXHJcbiAgICBhd2FpdCBzZXREb2MoZG9jUmVmLCB7XHJcbiAgICAgIHllYXJNb250aCxcclxuICAgICAgZGF5czogc2NoZWR1bGUsXHJcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfSlcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIHNhdmluZyBzY2hlZHVsZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb250aFNjaGVkdWxlKHllYXJNb250aDogc3RyaW5nKTogUHJvbWlzZTxNb250aFNjaGVkdWxlIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsIFwic2NoZWR1bGVzXCIsIHllYXJNb250aClcclxuICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBnZXREb2MoZG9jUmVmKVxyXG5cclxuICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2NTbmFwLmRhdGEoKVxyXG4gICAgICBjb25zdCBzY2hlZHVsZSA9IGRhdGEuZGF5cyBhcyBNb250aFNjaGVkdWxlXHJcbiAgICAgIC8vIOW+jOaWueS6kuaPm+aApzog5Y2Y5LiA44GuRGF5U2NoZWR1bGXjgpLphY3liJfjgavlpInmj5tcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZDogTW9udGhTY2hlZHVsZSA9IHt9XHJcbiAgICAgIGZvciAoY29uc3QgW2RhdGVTdHIsIGRheVNjaGVkdWxlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlZHVsZSkpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXlTY2hlZHVsZSkpIHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWRbZGF0ZVN0cl0gPSBkYXlTY2hlZHVsZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBub3JtYWxpemVkW2RhdGVTdHJdID0gW2RheVNjaGVkdWxlXVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXplZFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgZ2V0dGluZyBzY2hlZHVsZTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRTY2hlZHVsZVN0YXR1cygpOiBQcm9taXNlPHtcclxuICBpc09wZXJhdGluZzogYm9vbGVhblxyXG4gIHNjaGVkdWxlOiBEYXlTY2hlZHVsZSB8IG51bGxcclxuICBuZXh0T3BlcmF0aW9uPzoge1xyXG4gICAgZGF0ZTogc3RyaW5nXHJcbiAgICBkYXlPZldlZWs6IHN0cmluZ1xyXG4gICAgc3RhcnRUaW1lOiBzdHJpbmdcclxuICAgIGVuZFRpbWU6IHN0cmluZ1xyXG4gICAgc3RhcnRMb2NhdGlvbjogc3RyaW5nXHJcbiAgICByb3V0ZVR5cGU6IFwi5b6q55Kw44Or44O844OIXCIgfCBcIuODleODquODvOmBi+ihjFwiXHJcbiAgfVxyXG59IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXHJcbiAgICBjb25zdCB5ZWFyTW9udGggPSBgJHtub3cuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcobm93LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCBcIjBcIil9YFxyXG4gICAgY29uc3QgZGF0ZVN0ciA9IGAke25vdy5nZXRGdWxsWWVhcigpfS0ke1N0cmluZyhub3cuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKX0tJHtTdHJpbmcobm93LmdldERhdGUoKSkucGFkU3RhcnQoMiwgXCIwXCIpfWBcclxuXHJcbiAgICBjb25zdCBzY2hlZHVsZSA9IGF3YWl0IGdldE1vbnRoU2NoZWR1bGUoeWVhck1vbnRoKVxyXG4gICAgaWYgKCFzY2hlZHVsZSB8fCAhc2NoZWR1bGVbZGF0ZVN0cl0pIHtcclxuICAgICAgY29uc3QgbmV4dE9wID0gYXdhaXQgZmluZE5leHRPcGVyYXRpb24obm93KVxyXG4gICAgICByZXR1cm4geyBpc09wZXJhdGluZzogZmFsc2UsIHNjaGVkdWxlOiBudWxsLCBuZXh0T3BlcmF0aW9uOiBuZXh0T3AgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRheVNjaGVkdWxlcyA9IEFycmF5LmlzQXJyYXkoc2NoZWR1bGVbZGF0ZVN0cl0pID8gc2NoZWR1bGVbZGF0ZVN0cl0gOiBbc2NoZWR1bGVbZGF0ZVN0cl1dXHJcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGAke1N0cmluZyhub3cuZ2V0SG91cnMoKSkucGFkU3RhcnQoMiwgXCIwXCIpfToke1N0cmluZyhub3cuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCBcIjBcIil9YFxyXG5cclxuICAgIC8vIOePvuWcqOOBruaZgumWk+OBq+ipsuW9k+OBmeOCi+OCueOCseOCuOODpeODvOODq+OCkuaOouOBmVxyXG4gICAgY29uc3QgYWN0aXZlU2NoZWR1bGUgPSBkYXlTY2hlZHVsZXMuZmluZChcclxuICAgICAgKHMpID0+IHMuaXNPcGVyYXRpbmcgJiYgY3VycmVudFRpbWUgPj0gcy5zdGFydFRpbWUgJiYgY3VycmVudFRpbWUgPD0gcy5lbmRUaW1lLFxyXG4gICAgKVxyXG5cclxuICAgIGlmIChhY3RpdmVTY2hlZHVsZSkge1xyXG4gICAgICByZXR1cm4geyBpc09wZXJhdGluZzogdHJ1ZSwgc2NoZWR1bGU6IGFjdGl2ZVNjaGVkdWxlIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyDpgYvooYzkuK3jgafjga/jgarjgYTloLTlkIjjgIHmrKHlm57jga7pgYvooYzjgpLmjqLjgZlcclxuICAgIGNvbnN0IG5leHRPcCA9IGF3YWl0IGZpbmROZXh0T3BlcmF0aW9uKG5vdylcclxuICAgIHJldHVybiB7IGlzT3BlcmF0aW5nOiBmYWxzZSwgc2NoZWR1bGU6IGRheVNjaGVkdWxlc1swXSB8fCBudWxsLCBuZXh0T3BlcmF0aW9uOiBuZXh0T3AgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciBnZXR0aW5nIGN1cnJlbnQgc2NoZWR1bGUgc3RhdHVzOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBmaW5kTmV4dE9wZXJhdGlvbihmcm9tRGF0ZTogRGF0ZSk6IFByb21pc2U8XHJcbiAgfCB7XHJcbiAgICAgIGRhdGU6IHN0cmluZ1xyXG4gICAgICBkYXlPZldlZWs6IHN0cmluZ1xyXG4gICAgICBzdGFydFRpbWU6IHN0cmluZ1xyXG4gICAgICBlbmRUaW1lOiBzdHJpbmdcclxuICAgICAgc3RhcnRMb2NhdGlvbjogc3RyaW5nXHJcbiAgICAgIHJvdXRlVHlwZTogXCLlvqrnkrDjg6vjg7zjg4hcIiB8IFwi44OV44Oq44O86YGL6KGMXCJcclxuICAgIH1cclxuICB8IHVuZGVmaW5lZFxyXG4+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGF5TmFtZXMgPSBbXCLml6VcIiwgXCLmnIhcIiwgXCLngatcIiwgXCLmsLRcIiwgXCLmnKhcIiwgXCLph5FcIiwgXCLlnJ9cIl1cclxuXHJcbiAgICAvLyDku4rml6XjgYvjgokzMOaXpeW+jOOBvuOBp+aknOe0olxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGZyb21EYXRlKVxyXG4gICAgICBjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgaSlcclxuXHJcbiAgICAgIGNvbnN0IHllYXJNb250aCA9IGAke2NoZWNrRGF0ZS5nZXRGdWxsWWVhcigpfS0ke1N0cmluZyhjaGVja0RhdGUuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gXHJcbiAgICAgIGNvbnN0IGRhdGVTdHIgPSBgJHtjaGVja0RhdGUuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcoY2hlY2tEYXRlLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCBcIjBcIil9LSR7U3RyaW5nKGNoZWNrRGF0ZS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gXHJcblxyXG4gICAgICBjb25zdCBzY2hlZHVsZSA9IGF3YWl0IGdldE1vbnRoU2NoZWR1bGUoeWVhck1vbnRoKVxyXG4gICAgICBpZiAoIXNjaGVkdWxlIHx8ICFzY2hlZHVsZVtkYXRlU3RyXSkgY29udGludWVcclxuXHJcbiAgICAgIGNvbnN0IGRheVNjaGVkdWxlcyA9IEFycmF5LmlzQXJyYXkoc2NoZWR1bGVbZGF0ZVN0cl0pID8gc2NoZWR1bGVbZGF0ZVN0cl0gOiBbc2NoZWR1bGVbZGF0ZVN0cl1dXHJcbiAgICAgIGNvbnN0IG9wZXJhdGluZ1NjaGVkdWxlcyA9IGRheVNjaGVkdWxlcy5maWx0ZXIoKHMpID0+IHMuaXNPcGVyYXRpbmcpXHJcblxyXG4gICAgICBpZiAob3BlcmF0aW5nU2NoZWR1bGVzLmxlbmd0aCA9PT0gMCkgY29udGludWVcclxuXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gYCR7U3RyaW5nKGZyb21EYXRlLmdldEhvdXJzKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcoZnJvbURhdGUuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCBcIjBcIil9YFxyXG5cclxuICAgICAgLy8g5ZCM5pel44Gu5aC05ZCI44Gv44CB6YGL6KGM6ZaL5aeL5pmC5Yi744GM54++5Zyo5pmC5Yi744KI44KK5b6M44Gu44K544Kx44K444Ol44O844Or44KS5o6i44GZXHJcbiAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgY29uc3QgZnV0dXJlU2NoZWR1bGVzID0gb3BlcmF0aW5nU2NoZWR1bGVzLmZpbHRlcigocykgPT4gcy5zdGFydFRpbWUgPiBjdXJyZW50VGltZSlcclxuICAgICAgICBpZiAoZnV0dXJlU2NoZWR1bGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIOacgOOCgui/keOBhOacquadpeOBruOCueOCseOCuOODpeODvOODq+OCkumBuOaKnlxyXG4gICAgICAgICAgY29uc3QgbmV4dFNjaGVkdWxlID0gZnV0dXJlU2NoZWR1bGVzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRUaW1lLmxvY2FsZUNvbXBhcmUoYi5zdGFydFRpbWUpKVswXVxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0ZTogYCR7Y2hlY2tEYXRlLmdldE1vbnRoKCkgKyAxfS8ke2NoZWNrRGF0ZS5nZXREYXRlKCl9YCxcclxuICAgICAgICAgICAgZGF5T2ZXZWVrOiBkYXlOYW1lc1tjaGVja0RhdGUuZ2V0RGF5KCldLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU6IG5leHRTY2hlZHVsZS5zdGFydFRpbWUsXHJcbiAgICAgICAgICAgIGVuZFRpbWU6IG5leHRTY2hlZHVsZS5lbmRUaW1lLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBuZXh0U2NoZWR1bGUuc3RhcnRMb2NhdGlvbiB8fCBcIuODpOODs+ODnuODvOWJjVwiLFxyXG4gICAgICAgICAgICByb3V0ZVR5cGU6IG5leHRTY2hlZHVsZS5yb3V0ZVR5cGUsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOS7iuaXpeOBrumBi+ihjOaZgumWk+OBr+mBjuOBjuOBpuOBhOOCi+OBruOBp+asoeOBruaXpeOCkuaOouOBmVxyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIOS7luOBruaXpeOBruWgtOWQiOOBr+OAgeacgOWIneOBruOCueOCseOCuOODpeODvOODq+OCkui/lOOBmVxyXG4gICAgICBjb25zdCBmaXJzdFNjaGVkdWxlID0gb3BlcmF0aW5nU2NoZWR1bGVzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRUaW1lLmxvY2FsZUNvbXBhcmUoYi5zdGFydFRpbWUpKVswXVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGU6IGAke2NoZWNrRGF0ZS5nZXRNb250aCgpICsgMX0vJHtjaGVja0RhdGUuZ2V0RGF0ZSgpfWAsXHJcbiAgICAgICAgZGF5T2ZXZWVrOiBkYXlOYW1lc1tjaGVja0RhdGUuZ2V0RGF5KCldLFxyXG4gICAgICAgIHN0YXJ0VGltZTogZmlyc3RTY2hlZHVsZS5zdGFydFRpbWUsXHJcbiAgICAgICAgZW5kVGltZTogZmlyc3RTY2hlZHVsZS5lbmRUaW1lLFxyXG4gICAgICAgIHN0YXJ0TG9jYXRpb246IGZpcnN0U2NoZWR1bGUuc3RhcnRMb2NhdGlvbiB8fCBcIuODpOODs+ODnuODvOWJjVwiLFxyXG4gICAgICAgIHJvdXRlVHlwZTogZmlyc3RTY2hlZHVsZS5yb3V0ZVR5cGUsXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIGZpbmRpbmcgbmV4dCBvcGVyYXRpb246XCIsIGVycm9yKVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEFwcHMiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwicXVlcnkiLCJvcmRlckJ5Iiwib25TbmFwc2hvdCIsIlRpbWVzdGFtcCIsImRvYyIsImdldERvYyIsImdldERvY3MiLCJzZXREb2MiLCJzaW1wbGlmeVJvdXRlIiwicmVtb3ZlRHVwbGljYXRlUG9pbnRzIiwic25hcFRvUm9hZHMiLCJmaXJlYmFzZUNvbmZpZyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiYXV0aERvbWFpbiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOIiwicHJvamVjdElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCIsInN0b3JhZ2VCdWNrZXQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCIsImFwcElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lEIiwibWVhc3VyZW1lbnRJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FQVNVUkVNRU5UX0lEIiwiYXBwIiwibGVuZ3RoIiwiZGIiLCJnZXRSZWFsdGltZUxvY2F0aW9ucyIsImNvbGxlY3Rpb25OYW1lIiwiY2FsbGJhY2siLCJsb2NhdGlvbnNSZWYiLCJxIiwidW5zdWJzY3JpYmUiLCJzbmFwc2hvdCIsImxvY2F0aW9ucyIsImZvckVhY2giLCJkYXRhIiwicHVzaCIsImlkIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ0aW1lc3RhbXAiLCJ0b0RhdGUiLCJEYXRlIiwic3BlZWQiLCJhY2N1cmFjeSIsImVycm9yIiwiY29uc29sZSIsImdldEFjdGl2ZVJvdXRlIiwiZG9jUmVmIiwiZG9jU25hcCIsImV4aXN0cyIsInJvdXRlSWQiLCJnZXRTYXZlZFJvdXRlIiwiZ2V0U2F2ZWRSb3V0ZXMiLCJyb3V0ZXNSZWYiLCJkb2NzIiwibWFwIiwibmFtZSIsInBvaW50Q291bnQiLCJwb2ludHMiLCJnZXREYXRlQ29sbGVjdGlvbnMiLCJkYXRlTGlzdCIsInNvcnQiLCJhIiwiYiIsImRhdGVBIiwic3BsaXQiLCJkYXRlQiIsImxvY2FsZUNvbXBhcmUiLCJnZXRBbGxMb2NhdGlvbnNGcm9tQ29sbGVjdGlvbiIsInNhdmVSb3V0ZUFzQWN0aXZlIiwibG9jIiwibGF0IiwibG5nIiwidG9JU09TdHJpbmciLCJkZWR1cGxpY2F0ZWQiLCJsb2ciLCJzbmFwcGVkIiwiZmluYWxQb2ludHMiLCJzaW1wbGlmaWVkIiwicm91dGVEb2NSZWYiLCJzYXZlZFJvdXRlIiwiY3JlYXRlZEF0Iiwic2V0dGluZ3NEb2NSZWYiLCJhY3RpdmVTZXR0aW5ncyIsInVwZGF0ZWRBdCIsInNhdmVDdXN0b21Sb3V0ZSIsIm9wdGlvbnMiLCJzYXZlTW9udGhTY2hlZHVsZSIsInllYXJNb250aCIsInNjaGVkdWxlIiwiZGF5cyIsImdldE1vbnRoU2NoZWR1bGUiLCJub3JtYWxpemVkIiwiZGF0ZVN0ciIsImRheVNjaGVkdWxlIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsImdldEN1cnJlbnRTY2hlZHVsZVN0YXR1cyIsIm5vdyIsIlN0cmluZyIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImdldERhdGUiLCJuZXh0T3AiLCJmaW5kTmV4dE9wZXJhdGlvbiIsImlzT3BlcmF0aW5nIiwibmV4dE9wZXJhdGlvbiIsImRheVNjaGVkdWxlcyIsImN1cnJlbnRUaW1lIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiYWN0aXZlU2NoZWR1bGUiLCJmaW5kIiwicyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJmcm9tRGF0ZSIsImRheU5hbWVzIiwiaSIsImNoZWNrRGF0ZSIsInNldERhdGUiLCJvcGVyYXRpbmdTY2hlZHVsZXMiLCJmaWx0ZXIiLCJmdXR1cmVTY2hlZHVsZXMiLCJuZXh0U2NoZWR1bGUiLCJkYXRlIiwiZGF5T2ZXZWVrIiwiZ2V0RGF5Iiwic3RhcnRMb2NhdGlvbiIsInJvdXRlVHlwZSIsImZpcnN0U2NoZWR1bGUiLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase.ts\n"));

/***/ })

});