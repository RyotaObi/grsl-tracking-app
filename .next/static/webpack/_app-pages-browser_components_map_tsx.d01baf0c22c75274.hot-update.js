"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_map_tsx",{

/***/ "(app-pages-browser)/./components/map.tsx":
/*!****************************!*\
  !*** ./components/map.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Map)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Map(param) {\n    let { locations, plannedRoute, onMapReady, userLocation } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vehicleMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const traveledRouteRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const leafletRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const userMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            const loadLeaflet = {\n                \"Map.useEffect.loadLeaflet\": async ()=>{\n                    if (leafletRef.current) return;\n                    const L = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_leaflet_dist_leaflet-src_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\", 23));\n                    delete L.default.Icon.Default.prototype._getIconUrl;\n                    L.default.Icon.Default.mergeOptions({\n                        iconRetinaUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png\",\n                        iconUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png\",\n                        shadowUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png\"\n                    });\n                    leafletRef.current = L.default;\n                }\n            }[\"Map.useEffect.loadLeaflet\"];\n            loadLeaflet();\n        }\n    }[\"Map.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!containerRef.current || mapRef.current || !leafletRef.current) {\n                return;\n            }\n            const L = leafletRef.current;\n            const map = L.map(containerRef.current, {\n                zoomControl: false,\n                dragging: true,\n                touchZoom: true,\n                scrollWheelZoom: true,\n                doubleClickZoom: true,\n                boxZoom: true,\n                tap: true\n            }).setView([\n                35.6393079,\n                140.0465158\n            ], 15);\n            L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n                attribution: \"© OpenStreetMap contributors\",\n                maxZoom: 19\n            }).addTo(map);\n            mapRef.current = map;\n            if (onMapReady) {\n                onMapReady(map);\n            }\n            const timeoutId = setTimeout({\n                \"Map.useEffect.timeoutId\": ()=>{\n                    if (mapRef.current && mapRef.current.invalidateSize) {\n                        mapRef.current.invalidateSize();\n                    }\n                }\n            }[\"Map.useEffect.timeoutId\"], 100);\n            return ({\n                \"Map.useEffect\": ()=>{\n                    clearTimeout(timeoutId);\n                    if (mapRef.current) {\n                        mapRef.current.remove();\n                        mapRef.current = null;\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        onMapReady,\n        leafletRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !leafletRef.current) return;\n            // 既存のルートレイヤーを削除\n            if (routeLayerRef.current) {\n                routeLayerRef.current.remove();\n                routeLayerRef.current = null;\n            }\n            // ルートが空の場合はここで終了\n            if (!plannedRoute || plannedRoute.length === 0) {\n                return;\n            }\n            const updateRouteStyle = {\n                \"Map.useEffect.updateRouteStyle\": ()=>{\n                    if (!mapRef.current || !routeLayerRef.current) return;\n                    const zoom = mapRef.current.getZoom();\n                    const weight = Math.max(4, Math.min(14, 4 + (zoom - 15) * 2));\n                    routeLayerRef.current.setStyle({\n                        weight\n                    });\n                }\n            }[\"Map.useEffect.updateRouteStyle\"];\n            const routeLayer = leafletRef.current.polyline(plannedRoute, {\n                color: \"#2B7FFF\",\n                weight: 4,\n                opacity: 0.8\n            }).addTo(mapRef.current);\n            routeLayerRef.current = routeLayer;\n            mapRef.current.on(\"zoomend\", updateRouteStyle);\n            updateRouteStyle();\n            return ({\n                \"Map.useEffect\": ()=>{\n                    if (mapRef.current) {\n                        mapRef.current.off(\"zoomend\", updateRouteStyle);\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        plannedRoute\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || locations.length === 0 || !leafletRef.current) return;\n            const latestLocation = locations[locations.length - 1];\n            // 進行方向を計算（最新の位置とその前の位置から角度を計算）\n            let bearing = 0;\n            if (locations.length > 1) {\n                const prevLocation = locations[locations.length - 2];\n                const lat1 = prevLocation.latitude * Math.PI / 180;\n                const lat2 = latestLocation.latitude * Math.PI / 180;\n                const dLon = (latestLocation.longitude - prevLocation.longitude) * Math.PI / 180;\n                const y = Math.sin(dLon) * Math.cos(lat2);\n                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n                bearing = Math.atan2(y, x) * 180 / Math.PI;\n                bearing = (bearing + 360) % 360 // 0-360度に正規化\n                ;\n            }\n            // バスアイコンを作成（SVGを使用）\n            // 一意なIDを生成してシャドウフィルターの競合を避ける\n            const shadowId = \"shadow-\".concat(Math.random().toString(36).substr(2, 9));\n            // 三角形の底辺を円の接線に沿わせるため、進行方向に90度加算\n            // 三角形は円の右側から進行方向に向かって伸びる\n            const triangleRotation = bearing;\n            const vehicleIcon = leafletRef.current.divIcon({\n                className: \"vehicle-marker\",\n                html: '\\n        <svg width=\"48\" height=\"48\" viewBox=\"0 0 48 48\" style=\"filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));\">\\n          <defs>\\n            <filter id=\"'.concat(shadowId, '\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\\n              <feDropShadow dx=\"0\" dy=\"2\" stdDeviation=\"2\" flood-opacity=\"0.3\"/>\\n            </filter>\\n          </defs>\\n          <!-- 円形の緑色背景 -->\\n          <circle cx=\"20\" cy=\"24\" r=\"16\" fill=\"#00C950\" filter=\"url(#').concat(shadowId, ')\"/>\\n          <!-- 白いバスアイコン（車両位置ボタンと同じデザイン） -->\\n          <g transform=\"translate(20, 24) scale(0.5)\">\\n            <path d=\"M5 17h-2v-6l2-5h9l4 5v6h-2\" fill=\"white\" stroke=\"white\" stroke-width=\"0.5\"/>\\n            <circle cx=\"7\" cy=\"17\" r=\"2\" fill=\"white\"/>\\n            <path d=\"M9 17h6\" stroke=\"white\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\\n            <circle cx=\"17\" cy=\"17\" r=\"2\" fill=\"white\"/>\\n            <path d=\"M16 5l3 5\" stroke=\"white\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\\n            <path d=\"M5 11h11\" stroke=\"white\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\\n          </g>\\n          <!-- 三角形のポインター（進行方向に向く、底辺が円の接線に沿う） -->\\n          <g transform=\"translate(36, 24)\">\\n            <path\\n              d=\"M 0 0 L 8 -3 L 8 3 Z\"\\n              fill=\"#00C950\"\\n              filter=\"url(#').concat(shadowId, ')\"\\n              transform=\"rotate(').concat(triangleRotation, ')\"\\n            />\\n          </g>\\n        </svg>\\n      '),\n                iconSize: [\n                    48,\n                    48\n                ],\n                iconAnchor: [\n                    20,\n                    24\n                ]\n            });\n            if (vehicleMarkerRef.current) {\n                vehicleMarkerRef.current.setLatLng([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ]);\n                // アイコンを更新（角度が変わった場合）\n                vehicleMarkerRef.current.setIcon(vehicleIcon);\n            } else {\n                vehicleMarkerRef.current = leafletRef.current.marker([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ], {\n                    icon: vehicleIcon\n                }).addTo(mapRef.current);\n            }\n            if (locations.length > 1) {\n                const traveledPath = locations.map({\n                    \"Map.useEffect.traveledPath\": (loc)=>[\n                            loc.latitude,\n                            loc.longitude\n                        ]\n                }[\"Map.useEffect.traveledPath\"]);\n                if (traveledRouteRef.current) {\n                    traveledRouteRef.current.setLatLngs(traveledPath);\n                } else {\n                    traveledRouteRef.current = leafletRef.current.polyline(traveledPath, {\n                        color: \"#51A2FF\",\n                        weight: 3,\n                        opacity: 0.6,\n                        dashArray: \"10, 10\"\n                    }).addTo(mapRef.current);\n                }\n            }\n        }\n    }[\"Map.useEffect\"], [\n        locations\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !userLocation || !leafletRef.current) {\n                return;\n            }\n            if (userMarkerRef.current) {\n                userMarkerRef.current.setLatLng([\n                    userLocation.lat,\n                    userLocation.lng\n                ]);\n            } else {\n                const userIcon = leafletRef.current.divIcon({\n                    className: \"user-marker\",\n                    html: '\\n          <div style=\"\\n            width: 18px;\\n            height: 18px;\\n            background: #2B7FFF;\\n            border: 3px solid white;\\n            border-radius: 50%;\\n            box-shadow: 0 2px 8px rgba(0,0,0,0.3);\\n          \"></div>\\n        ',\n                    iconSize: [\n                        18,\n                        18\n                    ],\n                    iconAnchor: [\n                        9,\n                        9\n                    ]\n                });\n                userMarkerRef.current = leafletRef.current.marker([\n                    userLocation.lat,\n                    userLocation.lng\n                ], {\n                    icon: userIcon\n                }).addTo(mapRef.current);\n            }\n        }\n    }[\"Map.useEffect\"], [\n        userLocation\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            zIndex: 1,\n            isolation: \"isolate\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\admin\\\\Documents\\\\my-app\\\\components\\\\map.tsx\",\n        lineNumber: 251,\n        columnNumber: 5\n    }, this);\n}\n_s(Map, \"Zw70LtNQte49KqZQ7cuM5ejLcF4=\");\n_c = Map;\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxZQUFZO3dCQUFDO3dCQUFHO3FCQUFFO2dCQUNwQjtnQkFFQXRFLGNBQWNFLE9BQU8sR0FBR0gsV0FBV0csT0FBTyxDQUN2Q3VFLE1BQU0sQ0FBQztvQkFBQ2hGLGFBQWFzRixHQUFHO29CQUFFdEYsYUFBYXVGLEdBQUc7aUJBQUMsRUFBRTtvQkFDNUNOLE1BQU1PO2dCQUNSLEdBQ0N4RCxLQUFLLENBQUMvQixPQUFPUSxPQUFPO1lBQ3pCO1FBQ0Y7d0JBQUc7UUFBQ1Q7S0FBYTtJQUVqQixxQkFDRSw4REFBQ3lGO1FBQ0NDLEtBQUt4RjtRQUNMeUYsT0FBTztZQUNMQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxXQUFXO1FBQ2I7Ozs7OztBQUdOO0dBM1B3QnRHO0tBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxEb2N1bWVudHNcXG15LWFwcFxcY29tcG9uZW50c1xcbWFwLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIlxyXG5pbXBvcnQgdHlwZSB7IExvY2F0aW9uRGF0YSB9IGZyb20gXCJAL2xpYi90eXBlc1wiXHJcblxyXG5pbnRlcmZhY2UgTWFwUHJvcHMge1xyXG4gIGxvY2F0aW9uczogTG9jYXRpb25EYXRhW11cclxuICBwbGFubmVkUm91dGU/OiBbbnVtYmVyLCBudW1iZXJdW11cclxuICBvbk1hcFJlYWR5PzogKG1hcDogYW55KSA9PiB2b2lkXHJcbiAgdXNlckxvY2F0aW9uPzogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwKHsgbG9jYXRpb25zLCBwbGFubmVkUm91dGUsIG9uTWFwUmVhZHksIHVzZXJMb2NhdGlvbiB9OiBNYXBQcm9wcykge1xyXG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcclxuICBjb25zdCB2ZWhpY2xlTWFya2VyUmVmID0gdXNlUmVmPGFueSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3Qgcm91dGVMYXllclJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHRyYXZlbGVkUm91dGVSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbClcclxuICBjb25zdCBsZWFmbGV0UmVmID0gdXNlUmVmPGFueT4obnVsbClcclxuICBjb25zdCB1c2VyTWFya2VyUmVmID0gdXNlUmVmPGFueSB8IG51bGw+KG51bGwpXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBsb2FkTGVhZmxldCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKGxlYWZsZXRSZWYuY3VycmVudCkgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBMID0gYXdhaXQgaW1wb3J0KFwibGVhZmxldFwiKVxyXG5cclxuICAgICAgZGVsZXRlIChMLmRlZmF1bHQuSWNvbi5EZWZhdWx0LnByb3RvdHlwZSBhcyBhbnkpLl9nZXRJY29uVXJsXHJcbiAgICAgIEwuZGVmYXVsdC5JY29uLkRlZmF1bHQubWVyZ2VPcHRpb25zKHtcclxuICAgICAgICBpY29uUmV0aW5hVXJsOiBcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS45LjQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24tMngucG5nXCIsXHJcbiAgICAgICAgaWNvblVybDogXCJodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZ1wiLFxyXG4gICAgICAgIHNoYWRvd1VybDogXCJodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1zaGFkb3cucG5nXCIsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBsZWFmbGV0UmVmLmN1cnJlbnQgPSBMLmRlZmF1bHRcclxuICAgIH1cclxuXHJcbiAgICBsb2FkTGVhZmxldCgpXHJcbiAgfSwgW10pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50IHx8IG1hcFJlZi5jdXJyZW50IHx8ICFsZWFmbGV0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgTCA9IGxlYWZsZXRSZWYuY3VycmVudFxyXG5cclxuICAgIGNvbnN0IG1hcCA9IEwubWFwKGNvbnRhaW5lclJlZi5jdXJyZW50LCB7XHJcbiAgICAgIHpvb21Db250cm9sOiBmYWxzZSxcclxuICAgICAgZHJhZ2dpbmc6IHRydWUsXHJcbiAgICAgIHRvdWNoWm9vbTogdHJ1ZSxcclxuICAgICAgc2Nyb2xsV2hlZWxab29tOiB0cnVlLFxyXG4gICAgICBkb3VibGVDbGlja1pvb206IHRydWUsXHJcbiAgICAgIGJveFpvb206IHRydWUsXHJcbiAgICAgIHRhcDogdHJ1ZSxcclxuICAgIH0pLnNldFZpZXcoWzM1LjYzOTMwNzksIDE0MC4wNDY1MTU4XSwgMTUpXHJcblxyXG4gICAgTC50aWxlTGF5ZXIoXCJodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZ1wiLCB7XHJcbiAgICAgIGF0dHJpYnV0aW9uOiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIsXHJcbiAgICAgIG1heFpvb206IDE5LFxyXG4gICAgfSkuYWRkVG8obWFwKVxyXG5cclxuICAgIG1hcFJlZi5jdXJyZW50ID0gbWFwXHJcblxyXG4gICAgaWYgKG9uTWFwUmVhZHkpIHtcclxuICAgICAgb25NYXBSZWFkeShtYXApXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmIChtYXBSZWYuY3VycmVudCAmJiBtYXBSZWYuY3VycmVudC5pbnZhbGlkYXRlU2l6ZSkge1xyXG4gICAgICAgIG1hcFJlZi5jdXJyZW50LmludmFsaWRhdGVTaXplKClcclxuICAgICAgfVxyXG4gICAgfSwgMTAwKVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXHJcbiAgICAgIGlmIChtYXBSZWYuY3VycmVudCkge1xyXG4gICAgICAgIG1hcFJlZi5jdXJyZW50LnJlbW92ZSgpXHJcbiAgICAgICAgbWFwUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbb25NYXBSZWFkeSwgbGVhZmxldFJlZi5jdXJyZW50XSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwUmVmLmN1cnJlbnQgfHwgIWxlYWZsZXRSZWYuY3VycmVudCkgcmV0dXJuXHJcblxyXG4gICAgLy8g5pei5a2Y44Gu44Or44O844OI44Os44Kk44Ok44O844KS5YmK6ZmkXHJcbiAgICBpZiAocm91dGVMYXllclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJvdXRlTGF5ZXJSZWYuY3VycmVudC5yZW1vdmUoKVxyXG4gICAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgLy8g44Or44O844OI44GM56m644Gu5aC05ZCI44Gv44GT44GT44Gn57WC5LqGXHJcbiAgICBpZiAoIXBsYW5uZWRSb3V0ZSB8fCBwbGFubmVkUm91dGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZVJvdXRlU3R5bGUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghbWFwUmVmLmN1cnJlbnQgfHwgIXJvdXRlTGF5ZXJSZWYuY3VycmVudCkgcmV0dXJuXHJcbiAgICAgIGNvbnN0IHpvb20gPSBtYXBSZWYuY3VycmVudC5nZXRab29tKClcclxuICAgICAgY29uc3Qgd2VpZ2h0ID0gTWF0aC5tYXgoNCwgTWF0aC5taW4oMTQsIDQgKyAoem9vbSAtIDE1KSAqIDIpKVxyXG4gICAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQuc2V0U3R5bGUoeyB3ZWlnaHQgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByb3V0ZUxheWVyID0gbGVhZmxldFJlZi5jdXJyZW50XHJcbiAgICAgIC5wb2x5bGluZShwbGFubmVkUm91dGUsIHtcclxuICAgICAgICBjb2xvcjogXCIjMkI3RkZGXCIsXHJcbiAgICAgICAgd2VpZ2h0OiA0LFxyXG4gICAgICAgIG9wYWNpdHk6IDAuOCxcclxuICAgICAgfSlcclxuICAgICAgLmFkZFRvKG1hcFJlZi5jdXJyZW50KVxyXG5cclxuICAgIHJvdXRlTGF5ZXJSZWYuY3VycmVudCA9IHJvdXRlTGF5ZXJcclxuXHJcbiAgICBtYXBSZWYuY3VycmVudC5vbihcInpvb21lbmRcIiwgdXBkYXRlUm91dGVTdHlsZSlcclxuICAgIHVwZGF0ZVJvdXRlU3R5bGUoKVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChtYXBSZWYuY3VycmVudCkge1xyXG4gICAgICAgIG1hcFJlZi5jdXJyZW50Lm9mZihcInpvb21lbmRcIiwgdXBkYXRlUm91dGVTdHlsZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtwbGFubmVkUm91dGVdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCBsb2NhdGlvbnMubGVuZ3RoID09PSAwIHx8ICFsZWFmbGV0UmVmLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgIGNvbnN0IGxhdGVzdExvY2F0aW9uID0gbG9jYXRpb25zW2xvY2F0aW9ucy5sZW5ndGggLSAxXVxyXG5cclxuICAgIC8vIOmAsuihjOaWueWQkeOCkuioiOeul++8iOacgOaWsOOBruS9jee9ruOBqOOBneOBruWJjeOBruS9jee9ruOBi+OCieinkuW6puOCkuioiOeul++8iVxyXG4gICAgbGV0IGJlYXJpbmcgPSAwXHJcbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgY29uc3QgcHJldkxvY2F0aW9uID0gbG9jYXRpb25zW2xvY2F0aW9ucy5sZW5ndGggLSAyXVxyXG4gICAgICBjb25zdCBsYXQxID0gKHByZXZMb2NhdGlvbi5sYXRpdHVkZSAqIE1hdGguUEkpIC8gMTgwXHJcbiAgICAgIGNvbnN0IGxhdDIgPSAobGF0ZXN0TG9jYXRpb24ubGF0aXR1ZGUgKiBNYXRoLlBJKSAvIDE4MFxyXG4gICAgICBjb25zdCBkTG9uID0gKChsYXRlc3RMb2NhdGlvbi5sb25naXR1ZGUgLSBwcmV2TG9jYXRpb24ubG9uZ2l0dWRlKSAqIE1hdGguUEkpIC8gMTgwXHJcblxyXG4gICAgICBjb25zdCB5ID0gTWF0aC5zaW4oZExvbikgKiBNYXRoLmNvcyhsYXQyKVxyXG4gICAgICBjb25zdCB4ID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhkTG9uKVxyXG5cclxuICAgICAgYmVhcmluZyA9IChNYXRoLmF0YW4yKHksIHgpICogMTgwKSAvIE1hdGguUElcclxuICAgICAgYmVhcmluZyA9IChiZWFyaW5nICsgMzYwKSAlIDM2MCAvLyAwLTM2MOW6puOBq+ato+imj+WMllxyXG4gICAgfVxyXG5cclxuICAgIC8vIOODkOOCueOCouOCpOOCs+ODs+OCkuS9nOaIkO+8iFNWR+OCkuS9v+eUqO+8iVxyXG4gICAgLy8g5LiA5oSP44GqSUTjgpLnlJ/miJDjgZfjgabjgrfjg6Pjg4njgqbjg5XjgqPjg6vjgr/jg7zjga7nq7blkIjjgpLpgb/jgZHjgotcclxuICAgIGNvbnN0IHNoYWRvd0lkID0gYHNoYWRvdy0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXHJcbiAgICBcclxuICAgIC8vIOS4ieinkuW9ouOBruW6lei+uuOCkuWGhuOBruaOpee3muOBq+ayv+OCj+OBm+OCi+OBn+OCgeOAgemAsuihjOaWueWQkeOBqzkw5bqm5Yqg566XXHJcbiAgICAvLyDkuInop5LlvaLjga/lhobjga7lj7PlgbTjgYvjgonpgLLooYzmlrnlkJHjgavlkJHjgYvjgaPjgabkvLjjgbPjgotcclxuICAgIGNvbnN0IHRyaWFuZ2xlUm90YXRpb24gPSBiZWFyaW5nXHJcbiAgICBcclxuICAgIGNvbnN0IHZlaGljbGVJY29uID0gbGVhZmxldFJlZi5jdXJyZW50LmRpdkljb24oe1xyXG4gICAgICBjbGFzc05hbWU6IFwidmVoaWNsZS1tYXJrZXJcIixcclxuICAgICAgaHRtbDogYFxyXG4gICAgICAgIDxzdmcgd2lkdGg9XCI0OFwiIGhlaWdodD1cIjQ4XCIgdmlld0JveD1cIjAgMCA0OCA0OFwiIHN0eWxlPVwiZmlsdGVyOiBkcm9wLXNoYWRvdygwIDJweCA0cHggcmdiYSgwLDAsMCwwLjMpKTtcIj5cclxuICAgICAgICAgIDxkZWZzPlxyXG4gICAgICAgICAgICA8ZmlsdGVyIGlkPVwiJHtzaGFkb3dJZH1cIiB4PVwiLTUwJVwiIHk9XCItNTAlXCIgd2lkdGg9XCIyMDAlXCIgaGVpZ2h0PVwiMjAwJVwiPlxyXG4gICAgICAgICAgICAgIDxmZURyb3BTaGFkb3cgZHg9XCIwXCIgZHk9XCIyXCIgc3RkRGV2aWF0aW9uPVwiMlwiIGZsb29kLW9wYWNpdHk9XCIwLjNcIi8+XHJcbiAgICAgICAgICAgIDwvZmlsdGVyPlxyXG4gICAgICAgICAgPC9kZWZzPlxyXG4gICAgICAgICAgPCEtLSDlhoblvaLjga7nt5HoibLog4zmma8gLS0+XHJcbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjI0XCIgcj1cIjE2XCIgZmlsbD1cIiMwMEM5NTBcIiBmaWx0ZXI9XCJ1cmwoIyR7c2hhZG93SWR9KVwiLz5cclxuICAgICAgICAgIDwhLS0g55m944GE44OQ44K544Ki44Kk44Kz44Oz77yI6LuK5Lih5L2N572u44Oc44K/44Oz44Go5ZCM44GY44OH44K244Kk44Oz77yJIC0tPlxyXG4gICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIwLCAyNCkgc2NhbGUoMC41KVwiPlxyXG4gICAgICAgICAgICA8cGF0aCBkPVwiTTUgMTdoLTJ2LTZsMi01aDlsNCA1djZoLTJcIiBmaWxsPVwid2hpdGVcIiBzdHJva2U9XCJ3aGl0ZVwiIHN0cm9rZS13aWR0aD1cIjAuNVwiLz5cclxuICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjdcIiBjeT1cIjE3XCIgcj1cIjJcIiBmaWxsPVwid2hpdGVcIi8+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOSAxN2g2XCIgc3Ryb2tlPVwid2hpdGVcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxyXG4gICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTdcIiBjeT1cIjE3XCIgcj1cIjJcIiBmaWxsPVwid2hpdGVcIi8+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTYgNWwzIDVcIiBzdHJva2U9XCJ3aGl0ZVwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiLz5cclxuICAgICAgICAgICAgPHBhdGggZD1cIk01IDExaDExXCIgc3Ryb2tlPVwid2hpdGVcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxyXG4gICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgPCEtLSDkuInop5LlvaLjga7jg53jgqTjg7Pjgr/jg7zvvIjpgLLooYzmlrnlkJHjgavlkJHjgY/jgIHlupXovrrjgYzlhobjga7mjqXnt5rjgavmsr/jgYbvvIkgLS0+XHJcbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMzYsIDI0KVwiPlxyXG4gICAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICAgIGQ9XCJNIDAgMCBMIDggLTMgTCA4IDMgWlwiXHJcbiAgICAgICAgICAgICAgZmlsbD1cIiMwMEM5NTBcIlxyXG4gICAgICAgICAgICAgIGZpbHRlcj1cInVybCgjJHtzaGFkb3dJZH0pXCJcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJyb3RhdGUoJHt0cmlhbmdsZVJvdGF0aW9ufSlcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9nPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgICBgLFxyXG4gICAgICBpY29uU2l6ZTogWzQ4LCA0OF0sXHJcbiAgICAgIGljb25BbmNob3I6IFsyMCwgMjRdLCAvLyDlhobjga7kuK3lv4PjgpLkvY3nva7jgavlkIjjgo/jgZvjgotcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKHZlaGljbGVNYXJrZXJSZWYuY3VycmVudCkge1xyXG4gICAgICB2ZWhpY2xlTWFya2VyUmVmLmN1cnJlbnQuc2V0TGF0TG5nKFtsYXRlc3RMb2NhdGlvbi5sYXRpdHVkZSwgbGF0ZXN0TG9jYXRpb24ubG9uZ2l0dWRlXSlcclxuICAgICAgLy8g44Ki44Kk44Kz44Oz44KS5pu05paw77yI6KeS5bqm44GM5aSJ44KP44Gj44Gf5aC05ZCI77yJXHJcbiAgICAgIHZlaGljbGVNYXJrZXJSZWYuY3VycmVudC5zZXRJY29uKHZlaGljbGVJY29uKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmVoaWNsZU1hcmtlclJlZi5jdXJyZW50ID0gbGVhZmxldFJlZi5jdXJyZW50XHJcbiAgICAgICAgLm1hcmtlcihbbGF0ZXN0TG9jYXRpb24ubGF0aXR1ZGUsIGxhdGVzdExvY2F0aW9uLmxvbmdpdHVkZV0sIHtcclxuICAgICAgICAgIGljb246IHZlaGljbGVJY29uLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmFkZFRvKG1hcFJlZi5jdXJyZW50KVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCB0cmF2ZWxlZFBhdGggPSBsb2NhdGlvbnMubWFwKChsb2MpID0+IFtsb2MubGF0aXR1ZGUsIGxvYy5sb25naXR1ZGVdKSBhcyBbbnVtYmVyLCBudW1iZXJdW11cclxuXHJcbiAgICAgIGlmICh0cmF2ZWxlZFJvdXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICB0cmF2ZWxlZFJvdXRlUmVmLmN1cnJlbnQuc2V0TGF0TG5ncyh0cmF2ZWxlZFBhdGgpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJhdmVsZWRSb3V0ZVJlZi5jdXJyZW50ID0gbGVhZmxldFJlZi5jdXJyZW50XHJcbiAgICAgICAgICAucG9seWxpbmUodHJhdmVsZWRQYXRoLCB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiM1MUEyRkZcIixcclxuICAgICAgICAgICAgd2VpZ2h0OiAzLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjYsXHJcbiAgICAgICAgICAgIGRhc2hBcnJheTogXCIxMCwgMTBcIixcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuYWRkVG8obWFwUmVmLmN1cnJlbnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbbG9jYXRpb25zXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwUmVmLmN1cnJlbnQgfHwgIXVzZXJMb2NhdGlvbiB8fCAhbGVhZmxldFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VyTWFya2VyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgdXNlck1hcmtlclJlZi5jdXJyZW50LnNldExhdExuZyhbdXNlckxvY2F0aW9uLmxhdCwgdXNlckxvY2F0aW9uLmxuZ10pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCB1c2VySWNvbiA9IGxlYWZsZXRSZWYuY3VycmVudC5kaXZJY29uKHtcclxuICAgICAgICBjbGFzc05hbWU6IFwidXNlci1tYXJrZXJcIixcclxuICAgICAgICBodG1sOiBgXHJcbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiXHJcbiAgICAgICAgICAgIHdpZHRoOiAxOHB4O1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDE4cHg7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICMyQjdGRkY7XHJcbiAgICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xyXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsMCwwLDAuMyk7XHJcbiAgICAgICAgICBcIj48L2Rpdj5cclxuICAgICAgICBgLFxyXG4gICAgICAgIGljb25TaXplOiBbMTgsIDE4XSxcclxuICAgICAgICBpY29uQW5jaG9yOiBbOSwgOV0sXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICB1c2VyTWFya2VyUmVmLmN1cnJlbnQgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuICAgICAgICAubWFya2VyKFt1c2VyTG9jYXRpb24ubGF0LCB1c2VyTG9jYXRpb24ubG5nXSwge1xyXG4gICAgICAgICAgaWNvbjogdXNlckljb24sXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYWRkVG8obWFwUmVmLmN1cnJlbnQpXHJcbiAgICB9XHJcbiAgfSwgW3VzZXJMb2NhdGlvbl0pXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2XHJcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxyXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgekluZGV4OiAxLFxyXG4gICAgICAgIGlzb2xhdGlvbjogXCJpc29sYXRlXCIsXHJcbiAgICAgIH19XHJcbiAgICAvPlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiTWFwIiwibG9jYXRpb25zIiwicGxhbm5lZFJvdXRlIiwib25NYXBSZWFkeSIsInVzZXJMb2NhdGlvbiIsIm1hcFJlZiIsImNvbnRhaW5lclJlZiIsInZlaGljbGVNYXJrZXJSZWYiLCJyb3V0ZUxheWVyUmVmIiwidHJhdmVsZWRSb3V0ZVJlZiIsImxlYWZsZXRSZWYiLCJ1c2VyTWFya2VyUmVmIiwibG9hZExlYWZsZXQiLCJjdXJyZW50IiwiTCIsImRlZmF1bHQiLCJJY29uIiwiRGVmYXVsdCIsInByb3RvdHlwZSIsIl9nZXRJY29uVXJsIiwibWVyZ2VPcHRpb25zIiwiaWNvblJldGluYVVybCIsImljb25VcmwiLCJzaGFkb3dVcmwiLCJtYXAiLCJ6b29tQ29udHJvbCIsImRyYWdnaW5nIiwidG91Y2hab29tIiwic2Nyb2xsV2hlZWxab29tIiwiZG91YmxlQ2xpY2tab29tIiwiYm94Wm9vbSIsInRhcCIsInNldFZpZXciLCJ0aWxlTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsIm1heFpvb20iLCJhZGRUbyIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJpbnZhbGlkYXRlU2l6ZSIsImNsZWFyVGltZW91dCIsInJlbW92ZSIsImxlbmd0aCIsInVwZGF0ZVJvdXRlU3R5bGUiLCJ6b29tIiwiZ2V0Wm9vbSIsIndlaWdodCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRTdHlsZSIsInJvdXRlTGF5ZXIiLCJwb2x5bGluZSIsImNvbG9yIiwib3BhY2l0eSIsIm9uIiwib2ZmIiwibGF0ZXN0TG9jYXRpb24iLCJiZWFyaW5nIiwicHJldkxvY2F0aW9uIiwibGF0MSIsImxhdGl0dWRlIiwiUEkiLCJsYXQyIiwiZExvbiIsImxvbmdpdHVkZSIsInkiLCJzaW4iLCJjb3MiLCJ4IiwiYXRhbjIiLCJzaGFkb3dJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidHJpYW5nbGVSb3RhdGlvbiIsInZlaGljbGVJY29uIiwiZGl2SWNvbiIsImNsYXNzTmFtZSIsImh0bWwiLCJpY29uU2l6ZSIsImljb25BbmNob3IiLCJzZXRMYXRMbmciLCJzZXRJY29uIiwibWFya2VyIiwiaWNvbiIsInRyYXZlbGVkUGF0aCIsImxvYyIsInNldExhdExuZ3MiLCJkYXNoQXJyYXkiLCJsYXQiLCJsbmciLCJ1c2VySWNvbiIsImRpdiIsInJlZiIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ6SW5kZXgiLCJpc29sYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/map.tsx\n"));

/***/ })

});