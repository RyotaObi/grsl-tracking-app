"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_map_tsx",{

/***/ "(app-pages-browser)/./components/map.tsx":
/*!****************************!*\
  !*** ./components/map.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Map)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Map(param) {\n    let { locations, plannedRoute, onMapReady, userLocation } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vehicleMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const leafletRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const userMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            const loadLeaflet = {\n                \"Map.useEffect.loadLeaflet\": async ()=>{\n                    if (leafletRef.current) return;\n                    const L = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_leaflet_dist_leaflet-src_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\", 23));\n                    delete L.default.Icon.Default.prototype._getIconUrl;\n                    L.default.Icon.Default.mergeOptions({\n                        iconRetinaUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png\",\n                        iconUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png\",\n                        shadowUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png\"\n                    });\n                    leafletRef.current = L.default;\n                }\n            }[\"Map.useEffect.loadLeaflet\"];\n            loadLeaflet();\n        }\n    }[\"Map.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!containerRef.current || mapRef.current || !leafletRef.current) {\n                return;\n            }\n            const L = leafletRef.current;\n            const map = L.map(containerRef.current, {\n                zoomControl: false,\n                dragging: true,\n                touchZoom: true,\n                scrollWheelZoom: true,\n                doubleClickZoom: true,\n                boxZoom: true,\n                tap: true\n            }).setView([\n                35.6393079,\n                140.0465158\n            ], 15);\n            L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n                attribution: \"© OpenStreetMap contributors\",\n                maxZoom: 19\n            }).addTo(map);\n            mapRef.current = map;\n            if (onMapReady) {\n                onMapReady(map);\n            }\n            const timeoutId = setTimeout({\n                \"Map.useEffect.timeoutId\": ()=>{\n                    if (mapRef.current && mapRef.current.invalidateSize) {\n                        mapRef.current.invalidateSize();\n                    }\n                }\n            }[\"Map.useEffect.timeoutId\"], 100);\n            return ({\n                \"Map.useEffect\": ()=>{\n                    clearTimeout(timeoutId);\n                    if (mapRef.current) {\n                        mapRef.current.remove();\n                        mapRef.current = null;\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        onMapReady,\n        leafletRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !leafletRef.current) return;\n            // 既存のルートレイヤーを削除\n            if (routeLayerRef.current) {\n                routeLayerRef.current.remove();\n                routeLayerRef.current = null;\n            }\n            // ルートが空の場合はここで終了\n            if (!plannedRoute || plannedRoute.length === 0) {\n                return;\n            }\n            const updateRouteStyle = {\n                \"Map.useEffect.updateRouteStyle\": ()=>{\n                    if (!mapRef.current || !routeLayerRef.current) return;\n                    const zoom = mapRef.current.getZoom();\n                    const weight = Math.max(4, Math.min(14, 4 + (zoom - 15) * 2));\n                    routeLayerRef.current.setStyle({\n                        weight\n                    });\n                }\n            }[\"Map.useEffect.updateRouteStyle\"];\n            const routeLayer = leafletRef.current.polyline(plannedRoute, {\n                color: \"#2B7FFF\",\n                weight: 4,\n                opacity: 0.8\n            }).addTo(mapRef.current);\n            routeLayerRef.current = routeLayer;\n            mapRef.current.on(\"zoomend\", updateRouteStyle);\n            updateRouteStyle();\n            return ({\n                \"Map.useEffect\": ()=>{\n                    if (mapRef.current) {\n                        mapRef.current.off(\"zoomend\", updateRouteStyle);\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        plannedRoute\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || locations.length === 0 || !leafletRef.current) return;\n            const latestLocation = locations[locations.length - 1];\n            // 進行方向を計算（最新の位置とその前の位置から角度を計算）\n            let bearing = 0;\n            if (locations.length > 1) {\n                const prevLocation = locations[locations.length - 2];\n                const lat1 = prevLocation.latitude * Math.PI / 180;\n                const lat2 = latestLocation.latitude * Math.PI / 180;\n                const dLon = (latestLocation.longitude - prevLocation.longitude) * Math.PI / 180;\n                const y = Math.sin(dLon) * Math.cos(lat2);\n                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n                bearing = Math.atan2(y, x) * 180 / Math.PI;\n                bearing = (bearing + 360) % 360 // 0-360度に正規化\n                ;\n            }\n            // バスアイコンを作成（SVGを使用）\n            // 一意なIDを生成してシャドウフィルターの競合を避ける\n            const shadowId = \"shadow-\".concat(Math.random().toString(36).substr(2, 9));\n            // bearingをSVG座標系に変換（bearing: 0度=北、SVG: 0度=右）\n            // bearing 0度（北）→ SVG 270度（上）\n            // bearing 90度（東）→ SVG 0度（右）\n            // bearing 180度（南）→ SVG 90度（下）\n            // bearing 270度（西）→ SVG 180度（左）\n            const svgAngle = (90 - bearing) % 360;\n            const svgAngleRad = svgAngle * Math.PI / 180;\n            // 円の半径\n            const circleRadius = 20;\n            // 三角形の長さ（ストローク幅も考慮）\n            const triangleLength = 14;\n            const strokeWidth = 1.5;\n            // 余白（三角形が切れないように十分な余白を確保）\n            const padding = triangleLength + strokeWidth + 2;\n            // 円の中心（余白を考慮して配置）\n            const circleCenterX = 32 + padding;\n            const circleCenterY = 32 + padding;\n            // 進行方向に応じた円の接点の座標を計算\n            const triangleX = circleCenterX + circleRadius * Math.cos(svgAngleRad);\n            const triangleY = circleCenterY + circleRadius * Math.sin(svgAngleRad);\n            // 三角形が切れないようにSVGのサイズを拡大（余白を両側に追加）\n            const svgSize = 64 + padding * 2;\n            const vehicleIcon = leafletRef.current.divIcon({\n                className: \"vehicle-marker\",\n                html: '\\n        <svg width=\"'.concat(svgSize, '\" height=\"').concat(svgSize, '\" viewBox=\"0 0 ').concat(svgSize, \" \").concat(svgSize, '\" style=\"filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));\">\\n          <defs>\\n            <filter id=\"').concat(shadowId, '\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\\n              <feDropShadow dx=\"0\" dy=\"2\" stdDeviation=\"2\" flood-opacity=\"0.3\"/>\\n            </filter>\\n          </defs>\\n          <!-- 円形の緑色背景 -->\\n          <circle cx=\"').concat(circleCenterX, '\" cy=\"').concat(circleCenterY, '\" r=\"').concat(circleRadius, '\" fill=\"#00C950\" stroke=\"white\" stroke-width=\"1.5\" filter=\"url(#').concat(shadowId, ')\"/>\\n          <!-- 白いバスアイコン（シンプルなデザイン） -->\\n          <g transform=\"translate(').concat(circleCenterX, \", \").concat(circleCenterY, ')\">\\n            <!-- バスの本体（長方形） -->\\n            <rect x=\"-9\" y=\"-5\" width=\"18\" height=\"10\" rx=\"1\" fill=\"white\"/>\\n            <!-- バスの窓（2つの小さな長方形） -->\\n            <rect x=\"-6\" y=\"-3.5\" width=\"3.5\" height=\"2.5\" rx=\"0.3\" fill=\"#00C950\"/>\\n            <rect x=\"2.5\" y=\"-3.5\" width=\"3.5\" height=\"2.5\" rx=\"0.3\" fill=\"#00C950\"/>\\n            <!-- バスの車輪（2つの小さな円） -->\\n            <circle cx=\"-5.5\" cy=\"6\" r=\"2\" fill=\"white\"/>\\n            <circle cx=\"5.5\" cy=\"6\" r=\"2\" fill=\"white\"/>\\n          </g>\\n          <!-- 三角形のポインター（進行方向に応じて円の周囲の適切な位置に配置） -->\\n          <g transform=\"translate(').concat(triangleX, \", \").concat(triangleY, \") rotate(\").concat(svgAngle, ')\">\\n            <!-- 緑色の三角形（底辺が円の接線に沿う、鋭角が進行方向を指す） -->\\n            <path\\n              d=\"M -0.5 -8.5 L -0.5 8.5 L 14 -0.5 Z\"\\n              fill=\"#00C950\"\\n              stroke=\"white\"\\n              stroke-width=\"1.5\"\\n              filter=\"url(#').concat(shadowId, ')\"\\n            />\\n          </g>\\n        </svg>\\n      '),\n                iconSize: [\n                    svgSize,\n                    svgSize\n                ],\n                iconAnchor: [\n                    circleCenterX,\n                    circleCenterY\n                ]\n            });\n            if (vehicleMarkerRef.current) {\n                vehicleMarkerRef.current.setLatLng([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ]);\n                // アイコンを更新（角度が変わった場合）\n                vehicleMarkerRef.current.setIcon(vehicleIcon);\n            } else {\n                vehicleMarkerRef.current = leafletRef.current.marker([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ], {\n                    icon: vehicleIcon\n                }).addTo(mapRef.current);\n            }\n        }\n    }[\"Map.useEffect\"], [\n        locations\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !userLocation || !leafletRef.current) {\n                return;\n            }\n            if (userMarkerRef.current) {\n                userMarkerRef.current.setLatLng([\n                    userLocation.lat,\n                    userLocation.lng\n                ]);\n            } else {\n                const userIcon = leafletRef.current.divIcon({\n                    className: \"user-marker\",\n                    html: '\\n          <div style=\"\\n            width: 25px;\\n            height: 25px;\\n            background: #2B7FFF;\\n            border: 3px solid white;\\n            border-radius: 50%;\\n            box-shadow: 0 2px 8px rgba(0,0,0,0.3);\\n          \"></div>\\n        ',\n                    iconSize: [\n                        18,\n                        18\n                    ],\n                    iconAnchor: [\n                        9,\n                        9\n                    ]\n                });\n                userMarkerRef.current = leafletRef.current.marker([\n                    userLocation.lat,\n                    userLocation.lng\n                ], {\n                    icon: userIcon\n                }).addTo(mapRef.current);\n            }\n        }\n    }[\"Map.useEffect\"], [\n        userLocation\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            zIndex: 1,\n            isolation: \"isolate\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\admin\\\\Documents\\\\my-app\\\\components\\\\map.tsx\",\n        lineNumber: 260,\n        columnNumber: 5\n    }, this);\n}\n_s(Map, \"TLeDzsC8C7Cw0czMBDmoA67zTeM=\");\n_c = Map;\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFeUM7QUFVMUIsU0FBU0UsSUFBSSxLQUErRDtRQUEvRCxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxZQUFZLEVBQVksR0FBL0Q7O0lBQzFCLE1BQU1DLFNBQVNOLDZDQUFNQSxDQUFhO0lBQ2xDLE1BQU1PLGVBQWVQLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNUSxtQkFBbUJSLDZDQUFNQSxDQUFhO0lBQzVDLE1BQU1TLGdCQUFnQlQsNkNBQU1BLENBQWE7SUFDekMsTUFBTVUsYUFBYVYsNkNBQU1BLENBQU07SUFDL0IsTUFBTVcsZ0JBQWdCWCw2Q0FBTUEsQ0FBYTtJQUV6Q0QsZ0RBQVNBO3lCQUFDO1lBQ1IsTUFBTWE7NkNBQWM7b0JBQ2xCLElBQUlGLFdBQVdHLE9BQU8sRUFBRTtvQkFFeEIsTUFBTUMsSUFBSSxNQUFNLCtPQUFpQjtvQkFFakMsT0FBTyxFQUFHQyxPQUFPLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxTQUFTLENBQVNDLFdBQVc7b0JBQzVETCxFQUFFQyxPQUFPLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFDRyxZQUFZLENBQUM7d0JBQ2xDQyxlQUFlO3dCQUNmQyxTQUFTO3dCQUNUQyxXQUFXO29CQUNiO29CQUVBYixXQUFXRyxPQUFPLEdBQUdDLEVBQUVDLE9BQU87Z0JBQ2hDOztZQUVBSDtRQUNGO3dCQUFHLEVBQUU7SUFFTGIsZ0RBQVNBO3lCQUFDO1lBQ1IsSUFBSSxDQUFDUSxhQUFhTSxPQUFPLElBQUlQLE9BQU9PLE9BQU8sSUFBSSxDQUFDSCxXQUFXRyxPQUFPLEVBQUU7Z0JBQ2xFO1lBQ0Y7WUFFQSxNQUFNQyxJQUFJSixXQUFXRyxPQUFPO1lBRTVCLE1BQU1XLE1BQU1WLEVBQUVVLEdBQUcsQ0FBQ2pCLGFBQWFNLE9BQU8sRUFBRTtnQkFDdENZLGFBQWE7Z0JBQ2JDLFVBQVU7Z0JB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Z0JBQzNEO1lBQ0Y7WUFFQSxJQUFJRixjQUFjRSxPQUFPLEVBQUU7Z0JBQ3pCRixjQUFjRSxPQUFPLENBQUMrRSxTQUFTLENBQUM7b0JBQUN2RixhQUFhMkYsR0FBRztvQkFBRTNGLGFBQWE0RixHQUFHO2lCQUFDO1lBQ3RFLE9BQU87Z0JBQ0wsTUFBTUMsV0FBV3hGLFdBQVdHLE9BQU8sQ0FBQzBFLE9BQU8sQ0FBQztvQkFDMUNDLFdBQVc7b0JBQ1hDLE1BQU87b0JBVVBDLFVBQVU7d0JBQUM7d0JBQUk7cUJBQUc7b0JBQ2xCQyxZQUFZO3dCQUFDO3dCQUFHO3FCQUFFO2dCQUNwQjtnQkFFQWhGLGNBQWNFLE9BQU8sR0FBR0gsV0FBV0csT0FBTyxDQUN2Q2lGLE1BQU0sQ0FBQztvQkFBQ3pGLGFBQWEyRixHQUFHO29CQUFFM0YsYUFBYTRGLEdBQUc7aUJBQUMsRUFBRTtvQkFDNUNGLE1BQU1HO2dCQUNSLEdBQ0M5RCxLQUFLLENBQUM5QixPQUFPTyxPQUFPO1lBQ3pCO1FBQ0Y7d0JBQUc7UUFBQ1I7S0FBYTtJQUVqQixxQkFDRSw4REFBQzhGO1FBQ0NDLEtBQUs3RjtRQUNMOEYsT0FBTztZQUNMQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxXQUFXO1FBQ2I7Ozs7OztBQUdOO0dBcFF3QjNHO0tBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFkbWluXFxEb2N1bWVudHNcXG15LWFwcFxcY29tcG9uZW50c1xcbWFwLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIlxyXG5pbXBvcnQgdHlwZSB7IExvY2F0aW9uRGF0YSB9IGZyb20gXCJAL2xpYi90eXBlc1wiXHJcblxyXG5pbnRlcmZhY2UgTWFwUHJvcHMge1xyXG4gIGxvY2F0aW9uczogTG9jYXRpb25EYXRhW11cclxuICBwbGFubmVkUm91dGU/OiBbbnVtYmVyLCBudW1iZXJdW11cclxuICBvbk1hcFJlYWR5PzogKG1hcDogYW55KSA9PiB2b2lkXHJcbiAgdXNlckxvY2F0aW9uPzogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwKHsgbG9jYXRpb25zLCBwbGFubmVkUm91dGUsIG9uTWFwUmVhZHksIHVzZXJMb2NhdGlvbiB9OiBNYXBQcm9wcykge1xyXG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcclxuICBjb25zdCB2ZWhpY2xlTWFya2VyUmVmID0gdXNlUmVmPGFueSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3Qgcm91dGVMYXllclJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGxlYWZsZXRSZWYgPSB1c2VSZWY8YW55PihudWxsKVxyXG4gIGNvbnN0IHVzZXJNYXJrZXJSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbClcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGxvYWRMZWFmbGV0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAobGVhZmxldFJlZi5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IEwgPSBhd2FpdCBpbXBvcnQoXCJsZWFmbGV0XCIpXHJcblxyXG4gICAgICBkZWxldGUgKEwuZGVmYXVsdC5JY29uLkRlZmF1bHQucHJvdG90eXBlIGFzIGFueSkuX2dldEljb25VcmxcclxuICAgICAgTC5kZWZhdWx0Lkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xyXG4gICAgICAgIGljb25SZXRpbmFVcmw6IFwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjkuNC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi0yeC5wbmdcIixcclxuICAgICAgICBpY29uVXJsOiBcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS45LjQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nXCIsXHJcbiAgICAgICAgc2hhZG93VXJsOiBcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS45LjQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmdcIixcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGxlYWZsZXRSZWYuY3VycmVudCA9IEwuZGVmYXVsdFxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRMZWFmbGV0KClcclxuICB9LCBbXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQgfHwgbWFwUmVmLmN1cnJlbnQgfHwgIWxlYWZsZXRSZWYuY3VycmVudCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBMID0gbGVhZmxldFJlZi5jdXJyZW50XHJcblxyXG4gICAgY29uc3QgbWFwID0gTC5tYXAoY29udGFpbmVyUmVmLmN1cnJlbnQsIHtcclxuICAgICAgem9vbUNvbnRyb2w6IGZhbHNlLFxyXG4gICAgICBkcmFnZ2luZzogdHJ1ZSxcclxuICAgICAgdG91Y2hab29tOiB0cnVlLFxyXG4gICAgICBzY3JvbGxXaGVlbFpvb206IHRydWUsXHJcbiAgICAgIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcclxuICAgICAgYm94Wm9vbTogdHJ1ZSxcclxuICAgICAgdGFwOiB0cnVlLFxyXG4gICAgfSkuc2V0VmlldyhbMzUuNjM5MzA3OSwgMTQwLjA0NjUxNThdLCAxNSlcclxuXHJcbiAgICBMLnRpbGVMYXllcihcImh0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nXCIsIHtcclxuICAgICAgYXR0cmlidXRpb246IFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIixcclxuICAgICAgbWF4Wm9vbTogMTksXHJcbiAgICB9KS5hZGRUbyhtYXApXHJcblxyXG4gICAgbWFwUmVmLmN1cnJlbnQgPSBtYXBcclxuXHJcbiAgICBpZiAob25NYXBSZWFkeSkge1xyXG4gICAgICBvbk1hcFJlYWR5KG1hcClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKG1hcFJlZi5jdXJyZW50ICYmIG1hcFJlZi5jdXJyZW50LmludmFsaWRhdGVTaXplKSB7XHJcbiAgICAgICAgbWFwUmVmLmN1cnJlbnQuaW52YWxpZGF0ZVNpemUoKVxyXG4gICAgICB9XHJcbiAgICB9LCAxMDApXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcclxuICAgICAgaWYgKG1hcFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbWFwUmVmLmN1cnJlbnQucmVtb3ZlKClcclxuICAgICAgICBtYXBSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtvbk1hcFJlYWR5LCBsZWFmbGV0UmVmLmN1cnJlbnRdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCAhbGVhZmxldFJlZi5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAvLyDml6LlrZjjga7jg6vjg7zjg4jjg6zjgqTjg6Tjg7zjgpLliYrpmaRcclxuICAgIGlmIChyb3V0ZUxheWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcm91dGVMYXllclJlZi5jdXJyZW50LnJlbW92ZSgpXHJcbiAgICAgIHJvdXRlTGF5ZXJSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuXHJcbiAgICAvLyDjg6vjg7zjg4jjgYznqbrjga7loLTlkIjjga/jgZPjgZPjgafntYLkuoZcclxuICAgIGlmICghcGxhbm5lZFJvdXRlIHx8IHBsYW5uZWRSb3V0ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXBkYXRlUm91dGVTdHlsZSA9ICgpID0+IHtcclxuICAgICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCAhcm91dGVMYXllclJlZi5jdXJyZW50KSByZXR1cm5cclxuICAgICAgY29uc3Qgem9vbSA9IG1hcFJlZi5jdXJyZW50LmdldFpvb20oKVxyXG4gICAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLm1heCg0LCBNYXRoLm1pbigxNCwgNCArICh6b29tIC0gMTUpICogMikpXHJcbiAgICAgIHJvdXRlTGF5ZXJSZWYuY3VycmVudC5zZXRTdHlsZSh7IHdlaWdodCB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJvdXRlTGF5ZXIgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuICAgICAgLnBvbHlsaW5lKHBsYW5uZWRSb3V0ZSwge1xyXG4gICAgICAgIGNvbG9yOiBcIiMyQjdGRkZcIixcclxuICAgICAgICB3ZWlnaHQ6IDQsXHJcbiAgICAgICAgb3BhY2l0eTogMC44LFxyXG4gICAgICB9KVxyXG4gICAgICAuYWRkVG8obWFwUmVmLmN1cnJlbnQpXHJcblxyXG4gICAgcm91dGVMYXllclJlZi5jdXJyZW50ID0gcm91dGVMYXllclxyXG5cclxuICAgIG1hcFJlZi5jdXJyZW50Lm9uKFwiem9vbWVuZFwiLCB1cGRhdGVSb3V0ZVN0eWxlKVxyXG4gICAgdXBkYXRlUm91dGVTdHlsZSgpXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKG1hcFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbWFwUmVmLmN1cnJlbnQub2ZmKFwiem9vbWVuZFwiLCB1cGRhdGVSb3V0ZVN0eWxlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW3BsYW5uZWRSb3V0ZV0pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8IGxvY2F0aW9ucy5sZW5ndGggPT09IDAgfHwgIWxlYWZsZXRSZWYuY3VycmVudCkgcmV0dXJuXHJcblxyXG4gICAgY29uc3QgbGF0ZXN0TG9jYXRpb24gPSBsb2NhdGlvbnNbbG9jYXRpb25zLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgLy8g6YCy6KGM5pa55ZCR44KS6KiI566X77yI5pyA5paw44Gu5L2N572u44Go44Gd44Gu5YmN44Gu5L2N572u44GL44KJ6KeS5bqm44KS6KiI566X77yJXHJcbiAgICBsZXQgYmVhcmluZyA9IDBcclxuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCBwcmV2TG9jYXRpb24gPSBsb2NhdGlvbnNbbG9jYXRpb25zLmxlbmd0aCAtIDJdXHJcbiAgICAgIGNvbnN0IGxhdDEgPSAocHJldkxvY2F0aW9uLmxhdGl0dWRlICogTWF0aC5QSSkgLyAxODBcclxuICAgICAgY29uc3QgbGF0MiA9IChsYXRlc3RMb2NhdGlvbi5sYXRpdHVkZSAqIE1hdGguUEkpIC8gMTgwXHJcbiAgICAgIGNvbnN0IGRMb24gPSAoKGxhdGVzdExvY2F0aW9uLmxvbmdpdHVkZSAtIHByZXZMb2NhdGlvbi5sb25naXR1ZGUpICogTWF0aC5QSSkgLyAxODBcclxuXHJcbiAgICAgIGNvbnN0IHkgPSBNYXRoLnNpbihkTG9uKSAqIE1hdGguY29zKGxhdDIpXHJcbiAgICAgIGNvbnN0IHggPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxhdDIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGRMb24pXHJcblxyXG4gICAgICBiZWFyaW5nID0gKE1hdGguYXRhbjIoeSwgeCkgKiAxODApIC8gTWF0aC5QSVxyXG4gICAgICBiZWFyaW5nID0gKGJlYXJpbmcgKyAzNjApICUgMzYwIC8vIDAtMzYw5bqm44Gr5q2j6KaP5YyWXHJcbiAgICB9XHJcblxyXG4gICAgLy8g44OQ44K544Ki44Kk44Kz44Oz44KS5L2c5oiQ77yIU1ZH44KS5L2/55So77yJXHJcbiAgICAvLyDkuIDmhI/jgapJROOCkueUn+aIkOOBl+OBpuOCt+ODo+ODieOCpuODleOCo+ODq+OCv+ODvOOBruertuWQiOOCkumBv+OBkeOCi1xyXG4gICAgY29uc3Qgc2hhZG93SWQgPSBgc2hhZG93LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICAgIFxyXG4gICAgLy8gYmVhcmluZ+OCklNWR+W6p+aomeezu+OBq+WkieaPm++8iGJlYXJpbmc6IDDluqY95YyX44CBU1ZHOiAw5bqmPeWPs++8iVxyXG4gICAgLy8gYmVhcmluZyAw5bqm77yI5YyX77yJ4oaSIFNWRyAyNzDluqbvvIjkuIrvvIlcclxuICAgIC8vIGJlYXJpbmcgOTDluqbvvIjmnbHvvInihpIgU1ZHIDDluqbvvIjlj7PvvIlcclxuICAgIC8vIGJlYXJpbmcgMTgw5bqm77yI5Y2X77yJ4oaSIFNWRyA5MOW6pu+8iOS4i++8iVxyXG4gICAgLy8gYmVhcmluZyAyNzDluqbvvIjopb/vvInihpIgU1ZHIDE4MOW6pu+8iOW3pu+8iVxyXG4gICAgY29uc3Qgc3ZnQW5nbGUgPSAoOTAgLSBiZWFyaW5nKSAlIDM2MFxyXG4gICAgY29uc3Qgc3ZnQW5nbGVSYWQgPSAoc3ZnQW5nbGUgKiBNYXRoLlBJKSAvIDE4MFxyXG4gICAgXHJcbiAgICAvLyDlhobjga7ljYrlvoRcclxuICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IDIwXHJcbiAgICAvLyDkuInop5LlvaLjga7plbfjgZXvvIjjgrnjg4jjg63jg7zjgq/luYXjgoLogIPmha7vvIlcclxuICAgIGNvbnN0IHRyaWFuZ2xlTGVuZ3RoID0gMTRcclxuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gMS41XHJcbiAgICAvLyDkvZnnmb3vvIjkuInop5LlvaLjgYzliIfjgozjgarjgYTjgojjgYbjgavljYHliIbjgarkvZnnmb3jgpLnorrkv53vvIlcclxuICAgIGNvbnN0IHBhZGRpbmcgPSB0cmlhbmdsZUxlbmd0aCArIHN0cm9rZVdpZHRoICsgMlxyXG4gICAgXHJcbiAgICAvLyDlhobjga7kuK3lv4PvvIjkvZnnmb3jgpLogIPmha7jgZfjgabphY3nva7vvIlcclxuICAgIGNvbnN0IGNpcmNsZUNlbnRlclggPSAzMiArIHBhZGRpbmdcclxuICAgIGNvbnN0IGNpcmNsZUNlbnRlclkgPSAzMiArIHBhZGRpbmdcclxuICAgIFxyXG4gICAgLy8g6YCy6KGM5pa55ZCR44Gr5b+c44GY44Gf5YaG44Gu5o6l54K544Gu5bqn5qiZ44KS6KiI566XXHJcbiAgICBjb25zdCB0cmlhbmdsZVggPSBjaXJjbGVDZW50ZXJYICsgY2lyY2xlUmFkaXVzICogTWF0aC5jb3Moc3ZnQW5nbGVSYWQpXHJcbiAgICBjb25zdCB0cmlhbmdsZVkgPSBjaXJjbGVDZW50ZXJZICsgY2lyY2xlUmFkaXVzICogTWF0aC5zaW4oc3ZnQW5nbGVSYWQpXHJcbiAgICBcclxuICAgIC8vIOS4ieinkuW9ouOBjOWIh+OCjOOBquOBhOOCiOOBhuOBq1NWR+OBruOCteOCpOOCuuOCkuaLoeWkp++8iOS9meeZveOCkuS4oeWBtOOBq+i/veWKoO+8iVxyXG4gICAgY29uc3Qgc3ZnU2l6ZSA9IDY0ICsgcGFkZGluZyAqIDJcclxuICAgIFxyXG4gICAgY29uc3QgdmVoaWNsZUljb24gPSBsZWFmbGV0UmVmLmN1cnJlbnQuZGl2SWNvbih7XHJcbiAgICAgIGNsYXNzTmFtZTogXCJ2ZWhpY2xlLW1hcmtlclwiLFxyXG4gICAgICBodG1sOiBgXHJcbiAgICAgICAgPHN2ZyB3aWR0aD1cIiR7c3ZnU2l6ZX1cIiBoZWlnaHQ9XCIke3N2Z1NpemV9XCIgdmlld0JveD1cIjAgMCAke3N2Z1NpemV9ICR7c3ZnU2l6ZX1cIiBzdHlsZT1cImZpbHRlcjogZHJvcC1zaGFkb3coMCAycHggNHB4IHJnYmEoMCwwLDAsMC4zKSk7XCI+XHJcbiAgICAgICAgICA8ZGVmcz5cclxuICAgICAgICAgICAgPGZpbHRlciBpZD1cIiR7c2hhZG93SWR9XCIgeD1cIi01MCVcIiB5PVwiLTUwJVwiIHdpZHRoPVwiMjAwJVwiIGhlaWdodD1cIjIwMCVcIj5cclxuICAgICAgICAgICAgICA8ZmVEcm9wU2hhZG93IGR4PVwiMFwiIGR5PVwiMlwiIHN0ZERldmlhdGlvbj1cIjJcIiBmbG9vZC1vcGFjaXR5PVwiMC4zXCIvPlxyXG4gICAgICAgICAgICA8L2ZpbHRlcj5cclxuICAgICAgICAgIDwvZGVmcz5cclxuICAgICAgICAgIDwhLS0g5YaG5b2i44Gu57eR6Imy6IOM5pmvIC0tPlxyXG4gICAgICAgICAgPGNpcmNsZSBjeD1cIiR7Y2lyY2xlQ2VudGVyWH1cIiBjeT1cIiR7Y2lyY2xlQ2VudGVyWX1cIiByPVwiJHtjaXJjbGVSYWRpdXN9XCIgZmlsbD1cIiMwMEM5NTBcIiBzdHJva2U9XCJ3aGl0ZVwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIGZpbHRlcj1cInVybCgjJHtzaGFkb3dJZH0pXCIvPlxyXG4gICAgICAgICAgPCEtLSDnmb3jgYTjg5DjgrnjgqLjgqTjgrPjg7PvvIjjgrfjg7Pjg5fjg6vjgarjg4fjgrbjgqTjg7PvvIkgLS0+XHJcbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoJHtjaXJjbGVDZW50ZXJYfSwgJHtjaXJjbGVDZW50ZXJZfSlcIj5cclxuICAgICAgICAgICAgPCEtLSDjg5Djgrnjga7mnKzkvZPvvIjplbfmlrnlvaLvvIkgLS0+XHJcbiAgICAgICAgICAgIDxyZWN0IHg9XCItOVwiIHk9XCItNVwiIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMVwiIGZpbGw9XCJ3aGl0ZVwiLz5cclxuICAgICAgICAgICAgPCEtLSDjg5Djgrnjga7nqpPvvIgy44Gk44Gu5bCP44GV44Gq6ZW35pa55b2i77yJIC0tPlxyXG4gICAgICAgICAgICA8cmVjdCB4PVwiLTZcIiB5PVwiLTMuNVwiIHdpZHRoPVwiMy41XCIgaGVpZ2h0PVwiMi41XCIgcng9XCIwLjNcIiBmaWxsPVwiIzAwQzk1MFwiLz5cclxuICAgICAgICAgICAgPHJlY3QgeD1cIjIuNVwiIHk9XCItMy41XCIgd2lkdGg9XCIzLjVcIiBoZWlnaHQ9XCIyLjVcIiByeD1cIjAuM1wiIGZpbGw9XCIjMDBDOTUwXCIvPlxyXG4gICAgICAgICAgICA8IS0tIOODkOOCueOBrui7iui8qu+8iDLjgaTjga7lsI/jgZXjgarlhobvvIkgLS0+XHJcbiAgICAgICAgICAgIDxjaXJjbGUgY3g9XCItNS41XCIgY3k9XCI2XCIgcj1cIjJcIiBmaWxsPVwid2hpdGVcIi8+XHJcbiAgICAgICAgICAgIDxjaXJjbGUgY3g9XCI1LjVcIiBjeT1cIjZcIiByPVwiMlwiIGZpbGw9XCJ3aGl0ZVwiLz5cclxuICAgICAgICAgIDwvZz5cclxuICAgICAgICAgIDwhLS0g5LiJ6KeS5b2i44Gu44Od44Kk44Oz44K/44O877yI6YCy6KGM5pa55ZCR44Gr5b+c44GY44Gm5YaG44Gu5ZGo5Zuy44Gu6YGp5YiH44Gq5L2N572u44Gr6YWN572u77yJIC0tPlxyXG4gICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCR7dHJpYW5nbGVYfSwgJHt0cmlhbmdsZVl9KSByb3RhdGUoJHtzdmdBbmdsZX0pXCI+XHJcbiAgICAgICAgICAgIDwhLS0g57eR6Imy44Gu5LiJ6KeS5b2i77yI5bqV6L6644GM5YaG44Gu5o6l57ea44Gr5rK/44GG44CB6Yut6KeS44GM6YCy6KGM5pa55ZCR44KS5oyH44GZ77yJIC0tPlxyXG4gICAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICAgIGQ9XCJNIC0wLjUgLTguNSBMIC0wLjUgOC41IEwgMTQgLTAuNSBaXCJcclxuICAgICAgICAgICAgICBmaWxsPVwiIzAwQzk1MFwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwid2hpdGVcIlxyXG4gICAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjEuNVwiXHJcbiAgICAgICAgICAgICAgZmlsdGVyPVwidXJsKCMke3NoYWRvd0lkfSlcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9nPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgICBgLFxyXG4gICAgICBpY29uU2l6ZTogW3N2Z1NpemUsIHN2Z1NpemVdLFxyXG4gICAgICBpY29uQW5jaG9yOiBbY2lyY2xlQ2VudGVyWCwgY2lyY2xlQ2VudGVyWV0sIC8vIOWGhuOBruS4reW/g+OCkuS9jee9ruOBq+WQiOOCj+OBm+OCi1xyXG4gICAgfSlcclxuXHJcbiAgICBpZiAodmVoaWNsZU1hcmtlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHZlaGljbGVNYXJrZXJSZWYuY3VycmVudC5zZXRMYXRMbmcoW2xhdGVzdExvY2F0aW9uLmxhdGl0dWRlLCBsYXRlc3RMb2NhdGlvbi5sb25naXR1ZGVdKVxyXG4gICAgICAvLyDjgqLjgqTjgrPjg7PjgpLmm7TmlrDvvIjop5LluqbjgYzlpInjgo/jgaPjgZ/loLTlkIjvvIlcclxuICAgICAgdmVoaWNsZU1hcmtlclJlZi5jdXJyZW50LnNldEljb24odmVoaWNsZUljb24pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2ZWhpY2xlTWFya2VyUmVmLmN1cnJlbnQgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuICAgICAgICAubWFya2VyKFtsYXRlc3RMb2NhdGlvbi5sYXRpdHVkZSwgbGF0ZXN0TG9jYXRpb24ubG9uZ2l0dWRlXSwge1xyXG4gICAgICAgICAgaWNvbjogdmVoaWNsZUljb24sXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYWRkVG8obWFwUmVmLmN1cnJlbnQpXHJcbiAgICB9XHJcbiAgfSwgW2xvY2F0aW9uc10pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8ICF1c2VyTG9jYXRpb24gfHwgIWxlYWZsZXRSZWYuY3VycmVudCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBpZiAodXNlck1hcmtlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHVzZXJNYXJrZXJSZWYuY3VycmVudC5zZXRMYXRMbmcoW3VzZXJMb2NhdGlvbi5sYXQsIHVzZXJMb2NhdGlvbi5sbmddKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgdXNlckljb24gPSBsZWFmbGV0UmVmLmN1cnJlbnQuZGl2SWNvbih7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBcInVzZXItbWFya2VyXCIsXHJcbiAgICAgICAgaHRtbDogYFxyXG4gICAgICAgICAgPGRpdiBzdHlsZT1cIlxyXG4gICAgICAgICAgICB3aWR0aDogMjVweDtcclxuICAgICAgICAgICAgaGVpZ2h0OiAyNXB4O1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMkI3RkZGO1xyXG4gICAgICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcclxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLDAsMCwwLjMpO1xyXG4gICAgICAgICAgXCI+PC9kaXY+XHJcbiAgICAgICAgYCxcclxuICAgICAgICBpY29uU2l6ZTogWzE4LCAxOF0sXHJcbiAgICAgICAgaWNvbkFuY2hvcjogWzksIDldLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgdXNlck1hcmtlclJlZi5jdXJyZW50ID0gbGVhZmxldFJlZi5jdXJyZW50XHJcbiAgICAgICAgLm1hcmtlcihbdXNlckxvY2F0aW9uLmxhdCwgdXNlckxvY2F0aW9uLmxuZ10sIHtcclxuICAgICAgICAgIGljb246IHVzZXJJY29uLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmFkZFRvKG1hcFJlZi5jdXJyZW50KVxyXG4gICAgfVxyXG4gIH0sIFt1c2VyTG9jYXRpb25dKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdlxyXG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cclxuICAgICAgc3R5bGU9e3tcclxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHpJbmRleDogMSxcclxuICAgICAgICBpc29sYXRpb246IFwiaXNvbGF0ZVwiLFxyXG4gICAgICB9fVxyXG4gICAgLz5cclxuICApXHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIk1hcCIsImxvY2F0aW9ucyIsInBsYW5uZWRSb3V0ZSIsIm9uTWFwUmVhZHkiLCJ1c2VyTG9jYXRpb24iLCJtYXBSZWYiLCJjb250YWluZXJSZWYiLCJ2ZWhpY2xlTWFya2VyUmVmIiwicm91dGVMYXllclJlZiIsImxlYWZsZXRSZWYiLCJ1c2VyTWFya2VyUmVmIiwibG9hZExlYWZsZXQiLCJjdXJyZW50IiwiTCIsImRlZmF1bHQiLCJJY29uIiwiRGVmYXVsdCIsInByb3RvdHlwZSIsIl9nZXRJY29uVXJsIiwibWVyZ2VPcHRpb25zIiwiaWNvblJldGluYVVybCIsImljb25VcmwiLCJzaGFkb3dVcmwiLCJtYXAiLCJ6b29tQ29udHJvbCIsImRyYWdnaW5nIiwidG91Y2hab29tIiwic2Nyb2xsV2hlZWxab29tIiwiZG91YmxlQ2xpY2tab29tIiwiYm94Wm9vbSIsInRhcCIsInNldFZpZXciLCJ0aWxlTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsIm1heFpvb20iLCJhZGRUbyIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJpbnZhbGlkYXRlU2l6ZSIsImNsZWFyVGltZW91dCIsInJlbW92ZSIsImxlbmd0aCIsInVwZGF0ZVJvdXRlU3R5bGUiLCJ6b29tIiwiZ2V0Wm9vbSIsIndlaWdodCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzZXRTdHlsZSIsInJvdXRlTGF5ZXIiLCJwb2x5bGluZSIsImNvbG9yIiwib3BhY2l0eSIsIm9uIiwib2ZmIiwibGF0ZXN0TG9jYXRpb24iLCJiZWFyaW5nIiwicHJldkxvY2F0aW9uIiwibGF0MSIsImxhdGl0dWRlIiwiUEkiLCJsYXQyIiwiZExvbiIsImxvbmdpdHVkZSIsInkiLCJzaW4iLCJjb3MiLCJ4IiwiYXRhbjIiLCJzaGFkb3dJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwic3ZnQW5nbGUiLCJzdmdBbmdsZVJhZCIsImNpcmNsZVJhZGl1cyIsInRyaWFuZ2xlTGVuZ3RoIiwic3Ryb2tlV2lkdGgiLCJwYWRkaW5nIiwiY2lyY2xlQ2VudGVyWCIsImNpcmNsZUNlbnRlclkiLCJ0cmlhbmdsZVgiLCJ0cmlhbmdsZVkiLCJzdmdTaXplIiwidmVoaWNsZUljb24iLCJkaXZJY29uIiwiY2xhc3NOYW1lIiwiaHRtbCIsImljb25TaXplIiwiaWNvbkFuY2hvciIsInNldExhdExuZyIsInNldEljb24iLCJtYXJrZXIiLCJpY29uIiwibGF0IiwibG5nIiwidXNlckljb24iLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiekluZGV4IiwiaXNvbGF0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/map.tsx\n"));

/***/ })

});