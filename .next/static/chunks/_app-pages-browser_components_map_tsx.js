"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_map_tsx"],{

/***/ "(app-pages-browser)/./components/map.tsx":
/*!****************************!*\
  !*** ./components/map.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Map)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Map(param) {\n    let { locations, plannedRoute, onMapReady, userLocation } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const vehicleMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const routeLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const traveledRouteRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const leafletRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const userMarkerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            const loadLeaflet = {\n                \"Map.useEffect.loadLeaflet\": async ()=>{\n                    if (leafletRef.current) return;\n                    const L = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_leaflet_dist_leaflet-src_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\", 23));\n                    delete L.default.Icon.Default.prototype._getIconUrl;\n                    L.default.Icon.Default.mergeOptions({\n                        iconRetinaUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png\",\n                        iconUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png\",\n                        shadowUrl: \"https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png\"\n                    });\n                    leafletRef.current = L.default;\n                }\n            }[\"Map.useEffect.loadLeaflet\"];\n            loadLeaflet();\n        }\n    }[\"Map.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!containerRef.current || mapRef.current || !leafletRef.current) {\n                return;\n            }\n            const L = leafletRef.current;\n            const map = L.map(containerRef.current, {\n                zoomControl: false,\n                dragging: true,\n                touchZoom: true,\n                scrollWheelZoom: true,\n                doubleClickZoom: true,\n                boxZoom: true,\n                tap: true\n            }).setView([\n                35.6393079,\n                140.0465158\n            ], 15);\n            L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n                attribution: \"© OpenStreetMap contributors\",\n                maxZoom: 19\n            }).addTo(map);\n            mapRef.current = map;\n            if (onMapReady) {\n                onMapReady(map);\n            }\n            const timeoutId = setTimeout({\n                \"Map.useEffect.timeoutId\": ()=>{\n                    if (mapRef.current && mapRef.current.invalidateSize) {\n                        mapRef.current.invalidateSize();\n                    }\n                }\n            }[\"Map.useEffect.timeoutId\"], 100);\n            return ({\n                \"Map.useEffect\": ()=>{\n                    clearTimeout(timeoutId);\n                    if (mapRef.current) {\n                        mapRef.current.remove();\n                        mapRef.current = null;\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        onMapReady,\n        leafletRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !leafletRef.current) return;\n            // 既存のルートレイヤーを削除\n            if (routeLayerRef.current) {\n                routeLayerRef.current.remove();\n                routeLayerRef.current = null;\n            }\n            // ルートが空の場合はここで終了\n            if (!plannedRoute || plannedRoute.length === 0) {\n                return;\n            }\n            const updateRouteStyle = {\n                \"Map.useEffect.updateRouteStyle\": ()=>{\n                    if (!mapRef.current || !routeLayerRef.current) return;\n                    const zoom = mapRef.current.getZoom();\n                    const weight = Math.max(4, Math.min(14, 4 + (zoom - 15) * 2));\n                    routeLayerRef.current.setStyle({\n                        weight\n                    });\n                }\n            }[\"Map.useEffect.updateRouteStyle\"];\n            const routeLayer = leafletRef.current.polyline(plannedRoute, {\n                color: \"#2B7FFF\",\n                weight: 4,\n                opacity: 0.8\n            }).addTo(mapRef.current);\n            routeLayerRef.current = routeLayer;\n            mapRef.current.on(\"zoomend\", updateRouteStyle);\n            updateRouteStyle();\n            return ({\n                \"Map.useEffect\": ()=>{\n                    if (mapRef.current) {\n                        mapRef.current.off(\"zoomend\", updateRouteStyle);\n                    }\n                }\n            })[\"Map.useEffect\"];\n        }\n    }[\"Map.useEffect\"], [\n        plannedRoute\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || locations.length === 0 || !leafletRef.current) return;\n            const latestLocation = locations[locations.length - 1];\n            // 進行方向を計算（最新の位置とその前の位置から角度を計算）\n            let bearing = 0;\n            if (locations.length > 1) {\n                const prevLocation = locations[locations.length - 2];\n                const lat1 = prevLocation.latitude * Math.PI / 180;\n                const lat2 = latestLocation.latitude * Math.PI / 180;\n                const dLon = (latestLocation.longitude - prevLocation.longitude) * Math.PI / 180;\n                const y = Math.sin(dLon) * Math.cos(lat2);\n                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n                bearing = Math.atan2(y, x) * 180 / Math.PI;\n                bearing = (bearing + 360) % 360 // 0-360度に正規化\n                ;\n            }\n            // バスアイコンを作成（SVGを使用）\n            // 一意なIDを生成してシャドウフィルターの競合を避ける\n            const shadowId = \"shadow-\".concat(Math.random().toString(36).substr(2, 9));\n            // bearingをSVG座標系に変換（bearing: 0度=北、SVG: 0度=右）\n            // bearing 0度（北）→ SVG 270度（上）\n            // bearing 90度（東）→ SVG 0度（右）\n            // bearing 180度（南）→ SVG 90度（下）\n            // bearing 270度（西）→ SVG 180度（左）\n            const svgAngle = (90 - bearing) % 360;\n            const svgAngleRad = svgAngle * Math.PI / 180;\n            // 円の半径\n            const circleRadius = 20;\n            // 円の中心\n            const circleCenterX = 28;\n            const circleCenterY = 32;\n            // 進行方向に応じた円の接点の座標を計算\n            const triangleX = circleCenterX + circleRadius * Math.cos(svgAngleRad);\n            const triangleY = circleCenterY + circleRadius * Math.sin(svgAngleRad);\n            const vehicleIcon = leafletRef.current.divIcon({\n                className: \"vehicle-marker\",\n                html: '\\n        <svg width=\"64\" height=\"64\" viewBox=\"0 0 64 64\" style=\"filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));\">\\n          <defs>\\n            <filter id=\"'.concat(shadowId, '\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\\n              <feDropShadow dx=\"0\" dy=\"2\" stdDeviation=\"2\" flood-opacity=\"0.3\"/>\\n            </filter>\\n          </defs>\\n          <!-- 円形の緑色背景 -->\\n          <circle cx=\"').concat(circleCenterX, '\" cy=\"').concat(circleCenterY, '\" r=\"').concat(circleRadius, '\" fill=\"#00C950\" stroke=\"white\" stroke-width=\"1.5\" filter=\"url(#').concat(shadowId, ')\"/>\\n          <!-- 白いバスアイコン（シンプルなデザイン） -->\\n          <g transform=\"translate(').concat(circleCenterX, \", \").concat(circleCenterY, ')\">\\n            <!-- バスの本体（長方形） -->\\n            <rect x=\"-9\" y=\"-5\" width=\"18\" height=\"10\" rx=\"1\" fill=\"white\"/>\\n            <!-- バスの窓（2つの小さな長方形） -->\\n            <rect x=\"-6\" y=\"-3.5\" width=\"3.5\" height=\"2.5\" rx=\"0.3\" fill=\"#00C950\"/>\\n            <rect x=\"2.5\" y=\"-3.5\" width=\"3.5\" height=\"2.5\" rx=\"0.3\" fill=\"#00C950\"/>\\n            <!-- バスの車輪（2つの小さな円） -->\\n            <circle cx=\"-5.5\" cy=\"6\" r=\"2\" fill=\"white\"/>\\n            <circle cx=\"5.5\" cy=\"6\" r=\"2\" fill=\"white\"/>\\n          </g>\\n          <!-- 三角形のポインター（進行方向に応じて円の周囲の適切な位置に配置） -->\\n          <g transform=\"translate(').concat(triangleX, \", \").concat(triangleY, \") rotate(\").concat(svgAngle, ')\">\\n            <!-- 緑色の三角形（底辺が円の接線に沿う、鋭角が進行方向を指す） -->\\n            <path\\n              d=\"M -0.5 -8.5 L -0.5 8.5 L 14 -0.5 Z\"\\n              fill=\"#00C950\"\\n              stroke=\"white\"\\n              stroke-width=\"1.5\"\\n              filter=\"url(#').concat(shadowId, ')\"\\n            />\\n          </g>\\n        </svg>\\n      '),\n                iconSize: [\n                    64,\n                    64\n                ],\n                iconAnchor: [\n                    28,\n                    32\n                ]\n            });\n            if (vehicleMarkerRef.current) {\n                vehicleMarkerRef.current.setLatLng([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ]);\n                // アイコンを更新（角度が変わった場合）\n                vehicleMarkerRef.current.setIcon(vehicleIcon);\n            } else {\n                vehicleMarkerRef.current = leafletRef.current.marker([\n                    latestLocation.latitude,\n                    latestLocation.longitude\n                ], {\n                    icon: vehicleIcon\n                }).addTo(mapRef.current);\n            }\n            if (locations.length > 1) {\n                const traveledPath = locations.map({\n                    \"Map.useEffect.traveledPath\": (loc)=>[\n                            loc.latitude,\n                            loc.longitude\n                        ]\n                }[\"Map.useEffect.traveledPath\"]);\n                if (traveledRouteRef.current) {\n                    traveledRouteRef.current.setLatLngs(traveledPath);\n                } else {\n                    traveledRouteRef.current = leafletRef.current.polyline(traveledPath, {\n                        color: \"#51A2FF\",\n                        weight: 3,\n                        opacity: 0.6,\n                        dashArray: \"10, 10\"\n                    }).addTo(mapRef.current);\n                }\n            }\n        }\n    }[\"Map.useEffect\"], [\n        locations\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Map.useEffect\": ()=>{\n            if (!mapRef.current || !userLocation || !leafletRef.current) {\n                return;\n            }\n            if (userMarkerRef.current) {\n                userMarkerRef.current.setLatLng([\n                    userLocation.lat,\n                    userLocation.lng\n                ]);\n            } else {\n                const userIcon = leafletRef.current.divIcon({\n                    className: \"user-marker\",\n                    html: '\\n          <div style=\"\\n            width: 25px;\\n            height: 25px;\\n            background: #2B7FFF;\\n            border: 3px solid white;\\n            border-radius: 50%;\\n            box-shadow: 0 2px 8px rgba(0,0,0,0.3);\\n          \"></div>\\n        ',\n                    iconSize: [\n                        18,\n                        18\n                    ],\n                    iconAnchor: [\n                        9,\n                        9\n                    ]\n                });\n                userMarkerRef.current = leafletRef.current.marker([\n                    userLocation.lat,\n                    userLocation.lng\n                ], {\n                    icon: userIcon\n                }).addTo(mapRef.current);\n            }\n        }\n    }[\"Map.useEffect\"], [\n        userLocation\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\",\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            zIndex: 1,\n            isolation: \"isolate\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\admin\\\\Documents\\\\my-app\\\\components\\\\map.tsx\",\n        lineNumber: 269,\n        columnNumber: 5\n    }, this);\n}\n_s(Map, \"Zw70LtNQte49KqZQ7cuM5ejLcF4=\");\n_c = Map;\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFeUM7QUFVMUIsU0FBU0UsSUFBSSxLQUErRDtRQUEvRCxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxZQUFZLEVBQVksR0FBL0Q7O0lBQzFCLE1BQU1DLFNBQVNOLDZDQUFNQSxDQUFhO0lBQ2xDLE1BQU1PLGVBQWVQLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNUSxtQkFBbUJSLDZDQUFNQSxDQUFhO0lBQzVDLE1BQU1TLGdCQUFnQlQsNkNBQU1BLENBQWE7SUFDekMsTUFBTVUsbUJBQW1CViw2Q0FBTUEsQ0FBYTtJQUM1QyxNQUFNVyxhQUFhWCw2Q0FBTUEsQ0FBTTtJQUMvQixNQUFNWSxnQkFBZ0JaLDZDQUFNQSxDQUFhO0lBRXpDRCxnREFBU0E7eUJBQUM7WUFDUixNQUFNYzs2Q0FBYztvQkFDbEIsSUFBSUYsV0FBV0csT0FBTyxFQUFFO29CQUV4QixNQUFNQyxJQUFJLE1BQU0sK09BQWlCO29CQUVqQyxPQUFPLEVBQUdDLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLENBQUNDLFNBQVMsQ0FBU0MsV0FBVztvQkFDNURMLEVBQUVDLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLENBQUNHLFlBQVksQ0FBQzt3QkFDbENDLGVBQWU7d0JBQ2ZDLFNBQVM7d0JBQ1RDLFdBQVc7b0JBQ2I7b0JBRUFiLFdBQVdHLE9BQU8sR0FBR0MsRUFBRUMsT0FBTztnQkFDaEM7O1lBRUFIO1FBQ0Y7d0JBQUcsRUFBRTtJQUVMZCxnREFBU0E7eUJBQUM7WUFDUixJQUFJLENBQUNRLGFBQWFPLE9BQU8sSUFBSVIsT0FBT1EsT0FBTyxJQUFJLENBQUNILFdBQVdHLE9BQU8sRUFBRTtnQkFDbEU7WUFDRjtZQUVBLE1BQU1DLElBQUlKLFdBQVdHLE9BQU87WUFFNUIsTUFBTVcsTUFBTVYsRUFBRVUsR0FBRyxDQUFDbEIsYUFBYU8sT0FBTyxFQUFFO2dCQUN0Q1ksYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsV0FBVztnQkFDWEMsaUJBQWlCO2dCQUNqQkMsaUJBQWlCO2dCQUNqQkMsU0FBUztnQkFDVEMsS0FBSztZQUNQLEdBQUdDLE9BQU8sQ0FBQztnQkFBQztnQkFBWTthQUFZLEVBQUU7WUFFdENsQixFQUFFbUIsU0FBUyxDQUFDLHNEQUFzRDtnQkFDaEVDLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWCxHQUFHQyxLQUFLLENBQUNaO1lBRVRuQixPQUFPUSxPQUFPLEdBQUdXO1lBRWpCLElBQUlyQixZQUFZO2dCQUNkQSxXQUFXcUI7WUFDYjtZQUVBLE1BQU1hLFlBQVlDOzJDQUFXO29CQUMzQixJQUFJakMsT0FBT1EsT0FBTyxJQUFJUixPQUFPUSxPQUFPLENBQUMwQixjQUFjLEVBQUU7d0JBQ25EbEMsT0FBT1EsT0FBTyxDQUFDMEIsY0FBYztvQkFDL0I7Z0JBQ0Y7MENBQUc7WUFFSDtpQ0FBTztvQkFDTEMsYUFBYUg7b0JBQ2IsSUFBSWhDLE9BQU9RLE9BQU8sRUFBRTt3QkFDbEJSLE9BQU9RLE9BQU8sQ0FBQzRCLE1BQU07d0JBQ3JCcEMsT0FBT1EsT0FBTyxHQUFHO29CQUNuQjtnQkFDRjs7UUFDRjt3QkFBRztRQUFDVjtRQUFZTyxXQUFXRyxPQUFPO0tBQUM7SUFFbkNmLGdEQUFTQTt5QkFBQztZQUNSLElBQUksQ0FBQ08sT0FBT1EsT0FBTyxJQUFJLENBQUNILFdBQVdHLE9BQU8sRUFBRTtZQUU1QyxnQkFBZ0I7WUFDaEIsSUFBSUwsY0FBY0ssT0FBTyxFQUFFO2dCQUN6QkwsY0FBY0ssT0FBTyxDQUFDNEIsTUFBTTtnQkFDNUJqQyxjQUFjSyxPQUFPLEdBQUc7WUFDMUI7WUFFQSxpQkFBaUI7WUFDakIsSUFBSSxDQUFDWCxnQkFBZ0JBLGFBQWF3QyxNQUFNLEtBQUssR0FBRztnQkFDOUM7WUFDRjtZQUVBLE1BQU1DO2tEQUFtQjtvQkFDdkIsSUFBSSxDQUFDdEMsT0FBT1EsT0FBTyxJQUFJLENBQUNMLGNBQWNLLE9BQU8sRUFBRTtvQkFDL0MsTUFBTStCLE9BQU92QyxPQUFPUSxPQUFPLENBQUNnQyxPQUFPO29CQUNuQyxNQUFNQyxTQUFTQyxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDTCxPQUFPLEVBQUMsSUFBSztvQkFDMURwQyxjQUFjSyxPQUFPLENBQUNxQyxRQUFRLENBQUM7d0JBQUVKO29CQUFPO2dCQUMxQzs7WUFFQSxNQUFNSyxhQUFhekMsV0FBV0csT0FBTyxDQUNsQ3VDLFFBQVEsQ0FBQ2xELGNBQWM7Z0JBQ3RCbUQsT0FBTztnQkFDUFAsUUFBUTtnQkFDUlEsU0FBUztZQUNYLEdBQ0NsQixLQUFLLENBQUMvQixPQUFPUSxPQUFPO1lBRXZCTCxjQUFjSyxPQUFPLEdBQUdzQztZQUV4QjlDLE9BQU9RLE9BQU8sQ0FBQzBDLEVBQUUsQ0FBQyxXQUFXWjtZQUM3QkE7WUFFQTtpQ0FBTztvQkFDTCxJQUFJdEMsT0FBT1EsT0FBTyxFQUFFO3dCQUNsQlIsT0FBT1EsT0FBTyxDQUFDMkMsR0FBRyxDQUFDLFdBQVdiO29CQUNoQztnQkFDRjs7UUFDRjt3QkFBRztRQUFDekM7S0FBYTtJQUVqQkosZ0RBQVNBO3lCQUFDO1lBQ1IsSUFBSSxDQUFDTyxPQUFPUSxPQUFPLElBQUlaLFVBQVV5QyxNQUFNLEtBQUssS0FBSyxDQUFDaEMsV0FBV0csT0FBTyxFQUFFO1lBRXRFLE1BQU00QyxpQkFBaUJ4RCxTQUFTLENBQUNBLFVBQVV5QyxNQUFNLEdBQUcsRUFBRTtZQUV0RCwrQkFBK0I7WUFDL0IsSUFBSWdCLFVBQVU7WUFDZCxJQUFJekQsVUFBVXlDLE1BQU0sR0FBRyxHQUFHO2dCQUN4QixNQUFNaUIsZUFBZTFELFNBQVMsQ0FBQ0EsVUFBVXlDLE1BQU0sR0FBRyxFQUFFO2dCQUNwRCxNQUFNa0IsT0FBTyxhQUFjQyxRQUFRLEdBQUdkLEtBQUtlLEVBQUUsR0FBSTtnQkFDakQsTUFBTUMsT0FBTyxlQUFnQkYsUUFBUSxHQUFHZCxLQUFLZSxFQUFFLEdBQUk7Z0JBQ25ELE1BQU1FLE9BQU8sQ0FBRVAsZUFBZVEsU0FBUyxHQUFHTixhQUFhTSxTQUFTLElBQUlsQixLQUFLZSxFQUFFLEdBQUk7Z0JBRS9FLE1BQU1JLElBQUluQixLQUFLb0IsR0FBRyxDQUFDSCxRQUFRakIsS0FBS3FCLEdBQUcsQ0FBQ0w7Z0JBQ3BDLE1BQU1NLElBQUl0QixLQUFLcUIsR0FBRyxDQUFDUixRQUFRYixLQUFLb0IsR0FBRyxDQUFDSixRQUFRaEIsS0FBS29CLEdBQUcsQ0FBQ1AsUUFBUWIsS0FBS3FCLEdBQUcsQ0FBQ0wsUUFBUWhCLEtBQUtxQixHQUFHLENBQUNKO2dCQUV2Rk4sVUFBVSxLQUFNWSxLQUFLLENBQUNKLEdBQUdHLEtBQUssTUFBT3RCLEtBQUtlLEVBQUU7Z0JBQzVDSixVQUFVLENBQUNBLFVBQVUsR0FBRSxJQUFLLElBQUksYUFBYTs7WUFDL0M7WUFFQSxvQkFBb0I7WUFDcEIsNkJBQTZCO1lBQzdCLE1BQU1hLFdBQVcsVUFBa0QsT0FBeEN4QixLQUFLeUIsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7WUFFaEUsNkNBQTZDO1lBQzdDLDZCQUE2QjtZQUM3Qiw0QkFBNEI7WUFDNUIsOEJBQThCO1lBQzlCLCtCQUErQjtZQUMvQixNQUFNQyxXQUFXLENBQUMsS0FBS2pCLE9BQU0sSUFBSztZQUNsQyxNQUFNa0IsY0FBYyxXQUFZN0IsS0FBS2UsRUFBRSxHQUFJO1lBRTNDLE9BQU87WUFDUCxNQUFNZSxlQUFlO1lBQ3JCLE9BQU87WUFDUCxNQUFNQyxnQkFBZ0I7WUFDdEIsTUFBTUMsZ0JBQWdCO1lBRXRCLHFCQUFxQjtZQUNyQixNQUFNQyxZQUFZRixnQkFBZ0JELGVBQWU5QixLQUFLcUIsR0FBRyxDQUFDUTtZQUMxRCxNQUFNSyxZQUFZRixnQkFBZ0JGLGVBQWU5QixLQUFLb0IsR0FBRyxDQUFDUztZQUUxRCxNQUFNTSxjQUFjeEUsV0FBV0csT0FBTyxDQUFDc0UsT0FBTyxDQUFDO2dCQUM3Q0MsV0FBVztnQkFDWEMsTUFBTSxpS0FRWVAsT0FMRVAsVUFBUyxtT0FLV1EsT0FBdEJELGVBQWMsVUFBNkJELE9BQXJCRSxlQUFjLFNBQXNGUixPQUEvRU0sY0FBYSxvRUFFNUNDLE9BRjhHUCxVQUFTLG9GQUVyR1EsT0FBbEJELGVBQWMsTUFXZEUsT0FYa0JELGVBQWMsNGtCQVdsQkUsT0FBZEQsV0FBVSxNQUF5QkwsT0FBckJNLFdBQVUsYUFPL0JWLE9BUDBDSSxVQUFTLCtQQU8xQyxPQUFUSixVQUFTO2dCQUtoQ2UsVUFBVTtvQkFBQztvQkFBSTtpQkFBRztnQkFDbEJDLFlBQVk7b0JBQUM7b0JBQUk7aUJBQUc7WUFDdEI7WUFFQSxJQUFJaEYsaUJBQWlCTSxPQUFPLEVBQUU7Z0JBQzVCTixpQkFBaUJNLE9BQU8sQ0FBQzJFLFNBQVMsQ0FBQztvQkFBQy9CLGVBQWVJLFFBQVE7b0JBQUVKLGVBQWVRLFNBQVM7aUJBQUM7Z0JBQ3RGLHFCQUFxQjtnQkFDckIxRCxpQkFBaUJNLE9BQU8sQ0FBQzRFLE9BQU8sQ0FBQ1A7WUFDbkMsT0FBTztnQkFDTDNFLGlCQUFpQk0sT0FBTyxHQUFHSCxXQUFXRyxPQUFPLENBQzFDNkUsTUFBTSxDQUFDO29CQUFDakMsZUFBZUksUUFBUTtvQkFBRUosZUFBZVEsU0FBUztpQkFBQyxFQUFFO29CQUMzRDBCLE1BQU1UO2dCQUNSLEdBQ0M5QyxLQUFLLENBQUMvQixPQUFPUSxPQUFPO1lBQ3pCO1lBRUEsSUFBSVosVUFBVXlDLE1BQU0sR0FBRyxHQUFHO2dCQUN4QixNQUFNa0QsZUFBZTNGLFVBQVV1QixHQUFHO2tEQUFDLENBQUNxRSxNQUFROzRCQUFDQSxJQUFJaEMsUUFBUTs0QkFBRWdDLElBQUk1QixTQUFTO3lCQUFDOztnQkFFekUsSUFBSXhELGlCQUFpQkksT0FBTyxFQUFFO29CQUM1QkosaUJBQWlCSSxPQUFPLENBQUNpRixVQUFVLENBQUNGO2dCQUN0QyxPQUFPO29CQUNMbkYsaUJBQWlCSSxPQUFPLEdBQUdILFdBQVdHLE9BQU8sQ0FDMUN1QyxRQUFRLENBQUN3QyxjQUFjO3dCQUN0QnZDLE9BQU87d0JBQ1BQLFFBQVE7d0JBQ1JRLFNBQVM7d0JBQ1R5QyxXQUFXO29CQUNiLEdBQ0MzRCxLQUFLLENBQUMvQixPQUFPUSxPQUFPO2dCQUN6QjtZQUNGO1FBQ0Y7d0JBQUc7UUFBQ1o7S0FBVTtJQUVkSCxnREFBU0E7eUJBQUM7WUFDUixJQUFJLENBQUNPLE9BQU9RLE9BQU8sSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ00sV0FBV0csT0FBTyxFQUFFO2dCQUMzRDtZQUNGO1lBRUEsSUFBSUYsY0FBY0UsT0FBTyxFQUFFO2dCQUN6QkYsY0FBY0UsT0FBTyxDQUFDMkUsU0FBUyxDQUFDO29CQUFDcEYsYUFBYTRGLEdBQUc7b0JBQUU1RixhQUFhNkYsR0FBRztpQkFBQztZQUN0RSxPQUFPO2dCQUNMLE1BQU1DLFdBQVd4RixXQUFXRyxPQUFPLENBQUNzRSxPQUFPLENBQUM7b0JBQzFDQyxXQUFXO29CQUNYQyxNQUFPO29CQVVQQyxVQUFVO3dCQUFDO3dCQUFJO3FCQUFHO29CQUNsQkMsWUFBWTt3QkFBQzt3QkFBRztxQkFBRTtnQkFDcEI7Z0JBRUE1RSxjQUFjRSxPQUFPLEdBQUdILFdBQVdHLE9BQU8sQ0FDdkM2RSxNQUFNLENBQUM7b0JBQUN0RixhQUFhNEYsR0FBRztvQkFBRTVGLGFBQWE2RixHQUFHO2lCQUFDLEVBQUU7b0JBQzVDTixNQUFNTztnQkFDUixHQUNDOUQsS0FBSyxDQUFDL0IsT0FBT1EsT0FBTztZQUN6QjtRQUNGO3dCQUFHO1FBQUNUO0tBQWE7SUFFakIscUJBQ0UsOERBQUMrRjtRQUNDQyxLQUFLOUY7UUFDTCtGLE9BQU87WUFDTEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsS0FBSztZQUNMQyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsV0FBVztRQUNiOzs7Ozs7QUFHTjtHQTdRd0I1RztLQUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZG1pblxcRG9jdW1lbnRzXFxteS1hcHBcXGNvbXBvbmVudHNcXG1hcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCJcclxuaW1wb3J0IHR5cGUgeyBMb2NhdGlvbkRhdGEgfSBmcm9tIFwiQC9saWIvdHlwZXNcIlxyXG5cclxuaW50ZXJmYWNlIE1hcFByb3BzIHtcclxuICBsb2NhdGlvbnM6IExvY2F0aW9uRGF0YVtdXHJcbiAgcGxhbm5lZFJvdXRlPzogW251bWJlciwgbnVtYmVyXVtdXHJcbiAgb25NYXBSZWFkeT86IChtYXA6IGFueSkgPT4gdm9pZFxyXG4gIHVzZXJMb2NhdGlvbj86IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcCh7IGxvY2F0aW9ucywgcGxhbm5lZFJvdXRlLCBvbk1hcFJlYWR5LCB1c2VyTG9jYXRpb24gfTogTWFwUHJvcHMpIHtcclxuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbClcclxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXHJcbiAgY29uc3QgdmVoaWNsZU1hcmtlclJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHJvdXRlTGF5ZXJSZWYgPSB1c2VSZWY8YW55IHwgbnVsbD4obnVsbClcclxuICBjb25zdCB0cmF2ZWxlZFJvdXRlUmVmID0gdXNlUmVmPGFueSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgbGVhZmxldFJlZiA9IHVzZVJlZjxhbnk+KG51bGwpXHJcbiAgY29uc3QgdXNlck1hcmtlclJlZiA9IHVzZVJlZjxhbnkgfCBudWxsPihudWxsKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgbG9hZExlYWZsZXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGlmIChsZWFmbGV0UmVmLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgICAgY29uc3QgTCA9IGF3YWl0IGltcG9ydChcImxlYWZsZXRcIilcclxuXHJcbiAgICAgIGRlbGV0ZSAoTC5kZWZhdWx0Lkljb24uRGVmYXVsdC5wcm90b3R5cGUgYXMgYW55KS5fZ2V0SWNvblVybFxyXG4gICAgICBMLmRlZmF1bHQuSWNvbi5EZWZhdWx0Lm1lcmdlT3B0aW9ucyh7XHJcbiAgICAgICAgaWNvblJldGluYVVybDogXCJodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLTJ4LnBuZ1wiLFxyXG4gICAgICAgIGljb25Vcmw6IFwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjkuNC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcIixcclxuICAgICAgICBzaGFkb3dVcmw6IFwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjkuNC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZ1wiLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgbGVhZmxldFJlZi5jdXJyZW50ID0gTC5kZWZhdWx0XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZExlYWZsZXQoKVxyXG4gIH0sIFtdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCB8fCBtYXBSZWYuY3VycmVudCB8fCAhbGVhZmxldFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEwgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuXHJcbiAgICBjb25zdCBtYXAgPSBMLm1hcChjb250YWluZXJSZWYuY3VycmVudCwge1xyXG4gICAgICB6b29tQ29udHJvbDogZmFsc2UsXHJcbiAgICAgIGRyYWdnaW5nOiB0cnVlLFxyXG4gICAgICB0b3VjaFpvb206IHRydWUsXHJcbiAgICAgIHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcclxuICAgICAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxyXG4gICAgICBib3hab29tOiB0cnVlLFxyXG4gICAgICB0YXA6IHRydWUsXHJcbiAgICB9KS5zZXRWaWV3KFszNS42MzkzMDc5LCAxNDAuMDQ2NTE1OF0sIDE1KVxyXG5cclxuICAgIEwudGlsZUxheWVyKFwiaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmdcIiwge1xyXG4gICAgICBhdHRyaWJ1dGlvbjogXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLFxyXG4gICAgICBtYXhab29tOiAxOSxcclxuICAgIH0pLmFkZFRvKG1hcClcclxuXHJcbiAgICBtYXBSZWYuY3VycmVudCA9IG1hcFxyXG5cclxuICAgIGlmIChvbk1hcFJlYWR5KSB7XHJcbiAgICAgIG9uTWFwUmVhZHkobWFwKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAobWFwUmVmLmN1cnJlbnQgJiYgbWFwUmVmLmN1cnJlbnQuaW52YWxpZGF0ZVNpemUpIHtcclxuICAgICAgICBtYXBSZWYuY3VycmVudC5pbnZhbGlkYXRlU2l6ZSgpXHJcbiAgICAgIH1cclxuICAgIH0sIDEwMClcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxyXG4gICAgICBpZiAobWFwUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBtYXBSZWYuY3VycmVudC5yZW1vdmUoKVxyXG4gICAgICAgIG1hcFJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW29uTWFwUmVhZHksIGxlYWZsZXRSZWYuY3VycmVudF0pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8ICFsZWFmbGV0UmVmLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgIC8vIOaXouWtmOOBruODq+ODvOODiOODrOOCpOODpOODvOOCkuWJiumZpFxyXG4gICAgaWYgKHJvdXRlTGF5ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQucmVtb3ZlKClcclxuICAgICAgcm91dGVMYXllclJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIOODq+ODvOODiOOBjOepuuOBruWgtOWQiOOBr+OBk+OBk+OBp+e1guS6hlxyXG4gICAgaWYgKCFwbGFubmVkUm91dGUgfHwgcGxhbm5lZFJvdXRlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cGRhdGVSb3V0ZVN0eWxlID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIW1hcFJlZi5jdXJyZW50IHx8ICFyb3V0ZUxheWVyUmVmLmN1cnJlbnQpIHJldHVyblxyXG4gICAgICBjb25zdCB6b29tID0gbWFwUmVmLmN1cnJlbnQuZ2V0Wm9vbSgpXHJcbiAgICAgIGNvbnN0IHdlaWdodCA9IE1hdGgubWF4KDQsIE1hdGgubWluKDE0LCA0ICsgKHpvb20gLSAxNSkgKiAyKSlcclxuICAgICAgcm91dGVMYXllclJlZi5jdXJyZW50LnNldFN0eWxlKHsgd2VpZ2h0IH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgcm91dGVMYXllciA9IGxlYWZsZXRSZWYuY3VycmVudFxyXG4gICAgICAucG9seWxpbmUocGxhbm5lZFJvdXRlLCB7XHJcbiAgICAgICAgY29sb3I6IFwiIzJCN0ZGRlwiLFxyXG4gICAgICAgIHdlaWdodDogNCxcclxuICAgICAgICBvcGFjaXR5OiAwLjgsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5hZGRUbyhtYXBSZWYuY3VycmVudClcclxuXHJcbiAgICByb3V0ZUxheWVyUmVmLmN1cnJlbnQgPSByb3V0ZUxheWVyXHJcblxyXG4gICAgbWFwUmVmLmN1cnJlbnQub24oXCJ6b29tZW5kXCIsIHVwZGF0ZVJvdXRlU3R5bGUpXHJcbiAgICB1cGRhdGVSb3V0ZVN0eWxlKClcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAobWFwUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBtYXBSZWYuY3VycmVudC5vZmYoXCJ6b29tZW5kXCIsIHVwZGF0ZVJvdXRlU3R5bGUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbcGxhbm5lZFJvdXRlXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwUmVmLmN1cnJlbnQgfHwgbG9jYXRpb25zLmxlbmd0aCA9PT0gMCB8fCAhbGVhZmxldFJlZi5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICBjb25zdCBsYXRlc3RMb2NhdGlvbiA9IGxvY2F0aW9uc1tsb2NhdGlvbnMubGVuZ3RoIC0gMV1cclxuXHJcbiAgICAvLyDpgLLooYzmlrnlkJHjgpLoqIjnrpfvvIjmnIDmlrDjga7kvY3nva7jgajjgZ3jga7liY3jga7kvY3nva7jgYvjgonop5LluqbjgpLoqIjnrpfvvIlcclxuICAgIGxldCBiZWFyaW5nID0gMFxyXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGNvbnN0IHByZXZMb2NhdGlvbiA9IGxvY2F0aW9uc1tsb2NhdGlvbnMubGVuZ3RoIC0gMl1cclxuICAgICAgY29uc3QgbGF0MSA9IChwcmV2TG9jYXRpb24ubGF0aXR1ZGUgKiBNYXRoLlBJKSAvIDE4MFxyXG4gICAgICBjb25zdCBsYXQyID0gKGxhdGVzdExvY2F0aW9uLmxhdGl0dWRlICogTWF0aC5QSSkgLyAxODBcclxuICAgICAgY29uc3QgZExvbiA9ICgobGF0ZXN0TG9jYXRpb24ubG9uZ2l0dWRlIC0gcHJldkxvY2F0aW9uLmxvbmdpdHVkZSkgKiBNYXRoLlBJKSAvIDE4MFxyXG5cclxuICAgICAgY29uc3QgeSA9IE1hdGguc2luKGRMb24pICogTWF0aC5jb3MobGF0MilcclxuICAgICAgY29uc3QgeCA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLSBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MoZExvbilcclxuXHJcbiAgICAgIGJlYXJpbmcgPSAoTWF0aC5hdGFuMih5LCB4KSAqIDE4MCkgLyBNYXRoLlBJXHJcbiAgICAgIGJlYXJpbmcgPSAoYmVhcmluZyArIDM2MCkgJSAzNjAgLy8gMC0zNjDluqbjgavmraPopo/ljJZcclxuICAgIH1cclxuXHJcbiAgICAvLyDjg5DjgrnjgqLjgqTjgrPjg7PjgpLkvZzmiJDvvIhTVkfjgpLkvb/nlKjvvIlcclxuICAgIC8vIOS4gOaEj+OBqklE44KS55Sf5oiQ44GX44Gm44K344Oj44OJ44Km44OV44Kj44Or44K/44O844Gu56u25ZCI44KS6YG/44GR44KLXHJcbiAgICBjb25zdCBzaGFkb3dJZCA9IGBzaGFkb3ctJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxyXG4gICAgXHJcbiAgICAvLyBiZWFyaW5n44KSU1ZH5bqn5qiZ57O744Gr5aSJ5o+b77yIYmVhcmluZzogMOW6pj3ljJfjgIFTVkc6IDDluqY95Y+z77yJXHJcbiAgICAvLyBiZWFyaW5nIDDluqbvvIjljJfvvInihpIgU1ZHIDI3MOW6pu+8iOS4iu+8iVxyXG4gICAgLy8gYmVhcmluZyA5MOW6pu+8iOadse+8ieKGkiBTVkcgMOW6pu+8iOWPs++8iVxyXG4gICAgLy8gYmVhcmluZyAxODDluqbvvIjljZfvvInihpIgU1ZHIDkw5bqm77yI5LiL77yJXHJcbiAgICAvLyBiZWFyaW5nIDI3MOW6pu+8iOilv++8ieKGkiBTVkcgMTgw5bqm77yI5bem77yJXHJcbiAgICBjb25zdCBzdmdBbmdsZSA9ICg5MCAtIGJlYXJpbmcpICUgMzYwXHJcbiAgICBjb25zdCBzdmdBbmdsZVJhZCA9IChzdmdBbmdsZSAqIE1hdGguUEkpIC8gMTgwXHJcbiAgICBcclxuICAgIC8vIOWGhuOBruWNiuW+hFxyXG4gICAgY29uc3QgY2lyY2xlUmFkaXVzID0gMjBcclxuICAgIC8vIOWGhuOBruS4reW/g1xyXG4gICAgY29uc3QgY2lyY2xlQ2VudGVyWCA9IDI4XHJcbiAgICBjb25zdCBjaXJjbGVDZW50ZXJZID0gMzJcclxuICAgIFxyXG4gICAgLy8g6YCy6KGM5pa55ZCR44Gr5b+c44GY44Gf5YaG44Gu5o6l54K544Gu5bqn5qiZ44KS6KiI566XXHJcbiAgICBjb25zdCB0cmlhbmdsZVggPSBjaXJjbGVDZW50ZXJYICsgY2lyY2xlUmFkaXVzICogTWF0aC5jb3Moc3ZnQW5nbGVSYWQpXHJcbiAgICBjb25zdCB0cmlhbmdsZVkgPSBjaXJjbGVDZW50ZXJZICsgY2lyY2xlUmFkaXVzICogTWF0aC5zaW4oc3ZnQW5nbGVSYWQpXHJcbiAgICBcclxuICAgIGNvbnN0IHZlaGljbGVJY29uID0gbGVhZmxldFJlZi5jdXJyZW50LmRpdkljb24oe1xyXG4gICAgICBjbGFzc05hbWU6IFwidmVoaWNsZS1tYXJrZXJcIixcclxuICAgICAgaHRtbDogYFxyXG4gICAgICAgIDxzdmcgd2lkdGg9XCI2NFwiIGhlaWdodD1cIjY0XCIgdmlld0JveD1cIjAgMCA2NCA2NFwiIHN0eWxlPVwiZmlsdGVyOiBkcm9wLXNoYWRvdygwIDJweCA0cHggcmdiYSgwLDAsMCwwLjMpKTtcIj5cclxuICAgICAgICAgIDxkZWZzPlxyXG4gICAgICAgICAgICA8ZmlsdGVyIGlkPVwiJHtzaGFkb3dJZH1cIiB4PVwiLTUwJVwiIHk9XCItNTAlXCIgd2lkdGg9XCIyMDAlXCIgaGVpZ2h0PVwiMjAwJVwiPlxyXG4gICAgICAgICAgICAgIDxmZURyb3BTaGFkb3cgZHg9XCIwXCIgZHk9XCIyXCIgc3RkRGV2aWF0aW9uPVwiMlwiIGZsb29kLW9wYWNpdHk9XCIwLjNcIi8+XHJcbiAgICAgICAgICAgIDwvZmlsdGVyPlxyXG4gICAgICAgICAgPC9kZWZzPlxyXG4gICAgICAgICAgPCEtLSDlhoblvaLjga7nt5HoibLog4zmma8gLS0+XHJcbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiJHtjaXJjbGVDZW50ZXJYfVwiIGN5PVwiJHtjaXJjbGVDZW50ZXJZfVwiIHI9XCIke2NpcmNsZVJhZGl1c31cIiBmaWxsPVwiIzAwQzk1MFwiIHN0cm9rZT1cIndoaXRlXCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgZmlsdGVyPVwidXJsKCMke3NoYWRvd0lkfSlcIi8+XHJcbiAgICAgICAgICA8IS0tIOeZveOBhOODkOOCueOCouOCpOOCs+ODs++8iOOCt+ODs+ODl+ODq+OBquODh+OCtuOCpOODs++8iSAtLT5cclxuICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgke2NpcmNsZUNlbnRlclh9LCAke2NpcmNsZUNlbnRlcll9KVwiPlxyXG4gICAgICAgICAgICA8IS0tIOODkOOCueOBruacrOS9k++8iOmVt+aWueW9ou+8iSAtLT5cclxuICAgICAgICAgICAgPHJlY3QgeD1cIi05XCIgeT1cIi01XCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjEwXCIgcng9XCIxXCIgZmlsbD1cIndoaXRlXCIvPlxyXG4gICAgICAgICAgICA8IS0tIOODkOOCueOBrueqk++8iDLjgaTjga7lsI/jgZXjgarplbfmlrnlvaLvvIkgLS0+XHJcbiAgICAgICAgICAgIDxyZWN0IHg9XCItNlwiIHk9XCItMy41XCIgd2lkdGg9XCIzLjVcIiBoZWlnaHQ9XCIyLjVcIiByeD1cIjAuM1wiIGZpbGw9XCIjMDBDOTUwXCIvPlxyXG4gICAgICAgICAgICA8cmVjdCB4PVwiMi41XCIgeT1cIi0zLjVcIiB3aWR0aD1cIjMuNVwiIGhlaWdodD1cIjIuNVwiIHJ4PVwiMC4zXCIgZmlsbD1cIiMwMEM5NTBcIi8+XHJcbiAgICAgICAgICAgIDwhLS0g44OQ44K544Gu6LuK6Lyq77yIMuOBpOOBruWwj+OBleOBquWGhu+8iSAtLT5cclxuICAgICAgICAgICAgPGNpcmNsZSBjeD1cIi01LjVcIiBjeT1cIjZcIiByPVwiMlwiIGZpbGw9XCJ3aGl0ZVwiLz5cclxuICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjUuNVwiIGN5PVwiNlwiIHI9XCIyXCIgZmlsbD1cIndoaXRlXCIvPlxyXG4gICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgPCEtLSDkuInop5LlvaLjga7jg53jgqTjg7Pjgr/jg7zvvIjpgLLooYzmlrnlkJHjgavlv5zjgZjjgablhobjga7lkajlm7Ljga7pganliIfjgarkvY3nva7jgavphY3nva7vvIkgLS0+XHJcbiAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoJHt0cmlhbmdsZVh9LCAke3RyaWFuZ2xlWX0pIHJvdGF0ZSgke3N2Z0FuZ2xlfSlcIj5cclxuICAgICAgICAgICAgPCEtLSDnt5HoibLjga7kuInop5LlvaLvvIjlupXovrrjgYzlhobjga7mjqXnt5rjgavmsr/jgYbjgIHpi63op5LjgYzpgLLooYzmlrnlkJHjgpLmjIfjgZnvvIkgLS0+XHJcbiAgICAgICAgICAgIDxwYXRoXHJcbiAgICAgICAgICAgICAgZD1cIk0gLTAuNSAtOC41IEwgLTAuNSA4LjUgTCAxNCAtMC41IFpcIlxyXG4gICAgICAgICAgICAgIGZpbGw9XCIjMDBDOTUwXCJcclxuICAgICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXHJcbiAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMS41XCJcclxuICAgICAgICAgICAgICBmaWx0ZXI9XCJ1cmwoIyR7c2hhZG93SWR9KVwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2c+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgIGAsXHJcbiAgICAgIGljb25TaXplOiBbNjQsIDY0XSxcclxuICAgICAgaWNvbkFuY2hvcjogWzI4LCAzMl0sIC8vIOWGhuOBruS4reW/g+OCkuS9jee9ruOBq+WQiOOCj+OBm+OCi1xyXG4gICAgfSlcclxuXHJcbiAgICBpZiAodmVoaWNsZU1hcmtlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHZlaGljbGVNYXJrZXJSZWYuY3VycmVudC5zZXRMYXRMbmcoW2xhdGVzdExvY2F0aW9uLmxhdGl0dWRlLCBsYXRlc3RMb2NhdGlvbi5sb25naXR1ZGVdKVxyXG4gICAgICAvLyDjgqLjgqTjgrPjg7PjgpLmm7TmlrDvvIjop5LluqbjgYzlpInjgo/jgaPjgZ/loLTlkIjvvIlcclxuICAgICAgdmVoaWNsZU1hcmtlclJlZi5jdXJyZW50LnNldEljb24odmVoaWNsZUljb24pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2ZWhpY2xlTWFya2VyUmVmLmN1cnJlbnQgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuICAgICAgICAubWFya2VyKFtsYXRlc3RMb2NhdGlvbi5sYXRpdHVkZSwgbGF0ZXN0TG9jYXRpb24ubG9uZ2l0dWRlXSwge1xyXG4gICAgICAgICAgaWNvbjogdmVoaWNsZUljb24sXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYWRkVG8obWFwUmVmLmN1cnJlbnQpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGNvbnN0IHRyYXZlbGVkUGF0aCA9IGxvY2F0aW9ucy5tYXAoKGxvYykgPT4gW2xvYy5sYXRpdHVkZSwgbG9jLmxvbmdpdHVkZV0pIGFzIFtudW1iZXIsIG51bWJlcl1bXVxyXG5cclxuICAgICAgaWYgKHRyYXZlbGVkUm91dGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHRyYXZlbGVkUm91dGVSZWYuY3VycmVudC5zZXRMYXRMbmdzKHRyYXZlbGVkUGF0aClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cmF2ZWxlZFJvdXRlUmVmLmN1cnJlbnQgPSBsZWFmbGV0UmVmLmN1cnJlbnRcclxuICAgICAgICAgIC5wb2x5bGluZSh0cmF2ZWxlZFBhdGgsIHtcclxuICAgICAgICAgICAgY29sb3I6IFwiIzUxQTJGRlwiLFxyXG4gICAgICAgICAgICB3ZWlnaHQ6IDMsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNixcclxuICAgICAgICAgICAgZGFzaEFycmF5OiBcIjEwLCAxMFwiLFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5hZGRUbyhtYXBSZWYuY3VycmVudClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtsb2NhdGlvbnNdKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCAhdXNlckxvY2F0aW9uIHx8ICFsZWFmbGV0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVzZXJNYXJrZXJSZWYuY3VycmVudCkge1xyXG4gICAgICB1c2VyTWFya2VyUmVmLmN1cnJlbnQuc2V0TGF0TG5nKFt1c2VyTG9jYXRpb24ubGF0LCB1c2VyTG9jYXRpb24ubG5nXSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHVzZXJJY29uID0gbGVhZmxldFJlZi5jdXJyZW50LmRpdkljb24oe1xyXG4gICAgICAgIGNsYXNzTmFtZTogXCJ1c2VyLW1hcmtlclwiLFxyXG4gICAgICAgIGh0bWw6IGBcclxuICAgICAgICAgIDxkaXYgc3R5bGU9XCJcclxuICAgICAgICAgICAgd2lkdGg6IDI1cHg7XHJcbiAgICAgICAgICAgIGhlaWdodDogMjVweDtcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogIzJCN0ZGRjtcclxuICAgICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XHJcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwwLDAsMC4zKTtcclxuICAgICAgICAgIFwiPjwvZGl2PlxyXG4gICAgICAgIGAsXHJcbiAgICAgICAgaWNvblNpemU6IFsxOCwgMThdLFxyXG4gICAgICAgIGljb25BbmNob3I6IFs5LCA5XSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHVzZXJNYXJrZXJSZWYuY3VycmVudCA9IGxlYWZsZXRSZWYuY3VycmVudFxyXG4gICAgICAgIC5tYXJrZXIoW3VzZXJMb2NhdGlvbi5sYXQsIHVzZXJMb2NhdGlvbi5sbmddLCB7XHJcbiAgICAgICAgICBpY29uOiB1c2VySWNvbixcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hZGRUbyhtYXBSZWYuY3VycmVudClcclxuICAgIH1cclxuICB9LCBbdXNlckxvY2F0aW9uXSlcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXZcclxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXHJcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICB6SW5kZXg6IDEsXHJcbiAgICAgICAgaXNvbGF0aW9uOiBcImlzb2xhdGVcIixcclxuICAgICAgfX1cclxuICAgIC8+XHJcbiAgKVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJNYXAiLCJsb2NhdGlvbnMiLCJwbGFubmVkUm91dGUiLCJvbk1hcFJlYWR5IiwidXNlckxvY2F0aW9uIiwibWFwUmVmIiwiY29udGFpbmVyUmVmIiwidmVoaWNsZU1hcmtlclJlZiIsInJvdXRlTGF5ZXJSZWYiLCJ0cmF2ZWxlZFJvdXRlUmVmIiwibGVhZmxldFJlZiIsInVzZXJNYXJrZXJSZWYiLCJsb2FkTGVhZmxldCIsImN1cnJlbnQiLCJMIiwiZGVmYXVsdCIsIkljb24iLCJEZWZhdWx0IiwicHJvdG90eXBlIiwiX2dldEljb25VcmwiLCJtZXJnZU9wdGlvbnMiLCJpY29uUmV0aW5hVXJsIiwiaWNvblVybCIsInNoYWRvd1VybCIsIm1hcCIsInpvb21Db250cm9sIiwiZHJhZ2dpbmciLCJ0b3VjaFpvb20iLCJzY3JvbGxXaGVlbFpvb20iLCJkb3VibGVDbGlja1pvb20iLCJib3hab29tIiwidGFwIiwic2V0VmlldyIsInRpbGVMYXllciIsImF0dHJpYnV0aW9uIiwibWF4Wm9vbSIsImFkZFRvIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImludmFsaWRhdGVTaXplIiwiY2xlYXJUaW1lb3V0IiwicmVtb3ZlIiwibGVuZ3RoIiwidXBkYXRlUm91dGVTdHlsZSIsInpvb20iLCJnZXRab29tIiwid2VpZ2h0IiwiTWF0aCIsIm1heCIsIm1pbiIsInNldFN0eWxlIiwicm91dGVMYXllciIsInBvbHlsaW5lIiwiY29sb3IiLCJvcGFjaXR5Iiwib24iLCJvZmYiLCJsYXRlc3RMb2NhdGlvbiIsImJlYXJpbmciLCJwcmV2TG9jYXRpb24iLCJsYXQxIiwibGF0aXR1ZGUiLCJQSSIsImxhdDIiLCJkTG9uIiwibG9uZ2l0dWRlIiwieSIsInNpbiIsImNvcyIsIngiLCJhdGFuMiIsInNoYWRvd0lkIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzdmdBbmdsZSIsInN2Z0FuZ2xlUmFkIiwiY2lyY2xlUmFkaXVzIiwiY2lyY2xlQ2VudGVyWCIsImNpcmNsZUNlbnRlclkiLCJ0cmlhbmdsZVgiLCJ0cmlhbmdsZVkiLCJ2ZWhpY2xlSWNvbiIsImRpdkljb24iLCJjbGFzc05hbWUiLCJodG1sIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwic2V0TGF0TG5nIiwic2V0SWNvbiIsIm1hcmtlciIsImljb24iLCJ0cmF2ZWxlZFBhdGgiLCJsb2MiLCJzZXRMYXRMbmdzIiwiZGFzaEFycmF5IiwibGF0IiwibG5nIiwidXNlckljb24iLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiekluZGV4IiwiaXNvbGF0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/map.tsx\n"));

/***/ })

}]);